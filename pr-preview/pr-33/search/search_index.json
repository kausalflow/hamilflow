{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation for <code>hamilflow</code>","text":"<p>Generating dataset for physical systems.</p>"},{"location":"#development","title":"Development","text":"<p>We use <code>poetry</code> to manage our python environment. Use</p> <pre><code>poetry install\n</code></pre> <p>to install the requirements. Or run</p> <pre><code>poetry install --with test\n</code></pre> <p>to install the base environment and test environment for development.</p> <p>If this is the first you clone the repo and committing code, run</p> <pre><code>pre-commit install\n</code></pre> <p>first.</p>"},{"location":"changelog/","title":"hamilflow Changelog","text":""},{"location":"changelog/#010-2024-03-21","title":"0.1.0 (2024-03-21)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>model: add brownian motion (#23)</li> <li>ops: #18 use commitizen (#21)</li> </ul>"},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>docs: fix docstrings for pydantic models cvar (#27)</li> </ul>"},{"location":"changelog/#2024-02-18-001","title":"2024-02-18, 0.0.1","text":"<p>Setting up repository.</p>"},{"location":"references/","title":"References","text":""},{"location":"references/models/brownian_motion/","title":"Brownian Motion","text":""},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotion","title":"<code>BrownianMotion</code>","text":"<p>Brownian motion describes motion of small particles with stochastic forces applied to them. The math of Brownian motion can be modeled with Wiener process.</p> <p>For consistency, we always use \\(\\mathbf x\\) for displacement, and \\(t\\) for steps. The model we are using is</p> \\[ \\begin{align} \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) + \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t}) \\end{align} \\] <p>References:</p> <ol> <li>Brownian motion and random walks. [cited 13 Mar 2024].     Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html</li> <li>Contributors to Wikimedia projects. Brownian motion.     In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024].     Available: https://en.wikipedia.org/wiki/Brownian_motion</li> </ol> <p>1D Brownian Motion</p> <p>The dimsion of our Brownian motion is specified by the dimension of the initial condition.</p> <p>To simulate a 1D Browian motion, we define the system and initial condition:</p> <pre><code>system = {\n    \"sigma\": 1,\n    \"delta_t\": 1,\n}\n\ninitial_condition = {\n    \"x0\": 0\n}\n</code></pre> <p>The Brownian motion can be simulated using</p> <pre><code>bm = BrownianMotion(system=system, initial_condition=initial_condition)\n\nbm(n_steps=100)\n</code></pre> <p>2D Brownian Motion</p> <p>To simulate a 2D Browian motion,</p> <pre><code>system = {\n    \"sigma\": 1,\n    \"delta_t\": 1,\n}\n\ninitial_condition = {\n    \"x0\": [0, 0]\n}\n\nbm = BrownianMotion(system=system, initial_condition=initial_condition)\n\nbm(n_steps=100)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>Dict[str, float]</code> <p>the Brownian motion system definition</p> required <code>initial_condition</code> <code>Optional[Dict[str, float]]</code> <p>the initial condition for the simulation</p> <code>{}</code> Source code in <code>hamilflow/models/brownian_motion.py</code> <pre><code>class BrownianMotion:\n    r\"\"\"Brownian motion describes motion of small particles\n    with stochastic forces applied to them.\n    The math of Brownian motion can be modeled\n    with Wiener process.\n\n    For consistency, we always use\n    $\\mathbf x$ for displacement, and\n    $t$ for steps. The model we are using is\n\n    $$\n    \\begin{align}\n    \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) +\n    \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t})\n    \\end{align}\n    $$\n\n    References:\n\n    1. Brownian motion and random walks. [cited 13 Mar 2024].\n        Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html\n    2. Contributors to Wikimedia projects. Brownian motion.\n        In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024].\n        Available: https://en.wikipedia.org/wiki/Brownian_motion\n\n\n    !!! example \"1D Brownian Motion\"\n\n        The dimsion of our Brownian motion is specified by\n        the dimension of the initial condition.\n\n        To simulate a 1D Browian motion, we define the system and initial condition:\n\n        ```python\n        system = {\n            \"sigma\": 1,\n            \"delta_t\": 1,\n        }\n\n        initial_condition = {\n            \"x0\": 0\n        }\n        ```\n\n        The Brownian motion can be simulated using\n\n        ```python\n        bm = BrownianMotion(system=system, initial_condition=initial_condition)\n\n        bm(n_steps=100)\n        ```\n\n    !!! example \"2D Brownian Motion\"\n\n        To simulate a 2D Browian motion,\n\n        ```python\n        system = {\n            \"sigma\": 1,\n            \"delta_t\": 1,\n        }\n\n        initial_condition = {\n            \"x0\": [0, 0]\n        }\n\n        bm = BrownianMotion(system=system, initial_condition=initial_condition)\n\n        bm(n_steps=100)\n        ```\n\n    :param system: the Brownian motion system definition\n    :param initial_condition: the initial condition for the simulation\n    \"\"\"\n\n    def __init__(\n        self,\n        system: Dict[str, float],\n        initial_condition: Optional[Dict[str, float]] = {},\n    ):\n        self.system = BrownianMotionSystem.model_validate(system)\n        self.initial_condition = BrownianMotionIC.model_validate(initial_condition)\n\n    @property\n    def dim(self) -&gt; int:\n        \"\"\"Dimension of the Brownian motion\"\"\"\n        return self.initial_condition.x0.size\n\n    @property\n    def _axis_names(self) -&gt; List[str]:\n        return [f\"y_{i}\" for i in range(self.dim)]\n\n    def _trajectory(self, n_new_steps: int, seed: int) -&gt; np.ndarray:\n        \"\"\"The trajectory of the particle.\n\n        We first compute the delta displacement in each step.\n        With the displacement at each step, we perform a cumsum\n        including the initial coordinate to get the displacement at each step.\n\n        :param n_new_steps: number of new steps to simulate, excluding the initial step.\n        :param seed: seed for the random generator.\n        \"\"\"\n        step_history = sp.stats.norm.rvs(\n            size=(n_new_steps, self.dim) if self.dim &gt; 1 else n_new_steps,\n            scale=self.system.gaussian_scale,\n            random_state=np.random.RandomState(seed=seed),\n        )\n\n        step_history = np.concatenate(\n            (np.expand_dims(self.initial_condition.x0, axis=0), step_history)\n        )\n\n        trajectory = np.cumsum(step_history, axis=0)\n\n        return trajectory\n\n    def __call__(self, n_steps: int, seed: int = 42) -&gt; pd.DataFrame:\n        \"\"\"Simulate the coordinates of the particle\n\n        :param n_steps: total number of steps to be simulated, including the inital step.\n        :param seed: random generator seed for the stochastic process.\n            Use it to reproduce results.\n        \"\"\"\n        trajectory = self._trajectory(n_new_steps=n_steps - 1, seed=seed)\n\n        df = pd.DataFrame(trajectory, columns=self._axis_names)\n\n        df[\"t\"] = np.arange(0, n_steps) * self.system.delta_t\n\n        return df\n</code></pre>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotion.dim","title":"<code>dim: int</code>  <code>property</code>","text":"<p>Dimension of the Brownian motion</p>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotion.__call__","title":"<code>__call__(n_steps, seed=42)</code>","text":"<p>Simulate the coordinates of the particle</p> <p>Parameters:</p> Name Type Description Default <code>n_steps</code> <code>int</code> <p>total number of steps to be simulated, including the inital step.</p> required <code>seed</code> <code>int</code> <p>random generator seed for the stochastic process. Use it to reproduce results.</p> <code>42</code> Source code in <code>hamilflow/models/brownian_motion.py</code> <pre><code>def __call__(self, n_steps: int, seed: int = 42) -&gt; pd.DataFrame:\n    \"\"\"Simulate the coordinates of the particle\n\n    :param n_steps: total number of steps to be simulated, including the inital step.\n    :param seed: random generator seed for the stochastic process.\n        Use it to reproduce results.\n    \"\"\"\n    trajectory = self._trajectory(n_new_steps=n_steps - 1, seed=seed)\n\n    df = pd.DataFrame(trajectory, columns=self._axis_names)\n\n    df[\"t\"] = np.arange(0, n_steps) * self.system.delta_t\n\n    return df\n</code></pre>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotion._trajectory","title":"<code>_trajectory(n_new_steps, seed)</code>","text":"<p>The trajectory of the particle.</p> <p>We first compute the delta displacement in each step. With the displacement at each step, we perform a cumsum including the initial coordinate to get the displacement at each step.</p> <p>Parameters:</p> Name Type Description Default <code>n_new_steps</code> <code>int</code> <p>number of new steps to simulate, excluding the initial step.</p> required <code>seed</code> <code>int</code> <p>seed for the random generator.</p> required Source code in <code>hamilflow/models/brownian_motion.py</code> <pre><code>def _trajectory(self, n_new_steps: int, seed: int) -&gt; np.ndarray:\n    \"\"\"The trajectory of the particle.\n\n    We first compute the delta displacement in each step.\n    With the displacement at each step, we perform a cumsum\n    including the initial coordinate to get the displacement at each step.\n\n    :param n_new_steps: number of new steps to simulate, excluding the initial step.\n    :param seed: seed for the random generator.\n    \"\"\"\n    step_history = sp.stats.norm.rvs(\n        size=(n_new_steps, self.dim) if self.dim &gt; 1 else n_new_steps,\n        scale=self.system.gaussian_scale,\n        random_state=np.random.RandomState(seed=seed),\n    )\n\n    step_history = np.concatenate(\n        (np.expand_dims(self.initial_condition.x0, axis=0), step_history)\n    )\n\n    trajectory = np.cumsum(step_history, axis=0)\n\n    return trajectory\n</code></pre>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotionIC","title":"<code>BrownianMotionIC</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The initial condition for a Brownian motion</p> <p>Attributes:</p> Name Type Description <code>x0</code> <code>Union[float, int, List[Union[float, int]]]</code> <p>initial displacement of the particle, the diminsion of this initial condition determines the dimension of the model too.</p> Source code in <code>hamilflow/models/brownian_motion.py</code> <pre><code>class BrownianMotionIC(BaseModel):\n    \"\"\"The initial condition for a Brownian motion\n\n    :cvar x0: initial displacement of the particle,\n        the diminsion of this initial condition determines\n        the dimension of the model too.\n    \"\"\"\n\n    x0: Union[float, int, List[Union[float, int]]] = 1.0\n\n    @field_validator(\"x0\")\n    @classmethod\n    def check_x0_types(cls, v: Union[float, int, list]) -&gt; np.ndarray:\n        if not isinstance(v, (float, int, list)):\n            raise ValueError(f\"Value of x0 should be int/float/list of int/float: {v=}\")\n\n        return np.asarray(v)\n</code></pre>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotionSystem","title":"<code>BrownianMotionSystem</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Definition of the Brownian Motion system</p> <p>For consistency, we always use \\(\\mathbf x\\) for displacement, and \\(t\\) for steps. The model we are using is</p> \\[ \\begin{align} \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) + \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t}) \\end{align} \\] <p>References:</p> <ol> <li>Brownian motion and random walks. [cited 13 Mar 2024].     Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html</li> <li>Contributors to Wikimedia projects. Brownian motion.     In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024].     Available: https://en.wikipedia.org/wiki/Brownian_motion</li> </ol> <p>Attributes:</p> Name Type Description <code>sigma</code> <code>float</code> <p>base standard deviation to be used to compute the variance</p> <code>delta_t</code> <code>float</code> <p>time granunality of the motion</p> Source code in <code>hamilflow/models/brownian_motion.py</code> <pre><code>class BrownianMotionSystem(BaseModel):\n    r\"\"\"Definition of the Brownian Motion system\n\n    For consistency, we always use\n    $\\mathbf x$ for displacement, and\n    $t$ for steps. The model we are using is\n\n    $$\n    \\begin{align}\n    \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) +\n    \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t})\n    \\end{align}\n    $$\n\n    References:\n\n    1. Brownian motion and random walks. [cited 13 Mar 2024].\n        Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html\n    2. Contributors to Wikimedia projects. Brownian motion.\n        In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024].\n        Available: https://en.wikipedia.org/wiki/Brownian_motion\n\n    :cvar sigma: base standard deviation\n        to be used to compute the variance\n    :cvar delta_t: time granunality of the motion\n    \"\"\"\n\n    sigma: float = Field(ge=0)\n    delta_t: float = Field(ge=0, default=1.0)\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def gaussian_scale(self) -&gt; float:\n        \"\"\"The scale (standard deviation) of the Gaussian term\n        in Brownian motion\n        \"\"\"\n        return self.sigma**2 * self.delta_t\n</code></pre>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotionSystem.gaussian_scale","title":"<code>gaussian_scale: float</code>  <code>cached</code> <code>property</code>","text":"<p>The scale (standard deviation) of the Gaussian term in Brownian motion</p>"},{"location":"references/models/harmonic_oscillator/","title":"Harmonic Oscillator","text":""},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillator","title":"<code>HarmonicOscillator</code>","text":"<p>Generate time series data for a harmonic oscillator.</p> <p>The equation for a general un-driven harmonic oscillator is<sup>1</sup><sup>2</sup></p> \\[ \\frac{\\mathrm d x^2}{\\mathrm d t^2} + 2\\zeta \\omega \\frac{\\mathrm d x}{\\mathrm dt} + \\omega^2 x = 0, \\] <p>where \\(x\\) is the displacement, \\(\\omega\\) is the angular frequency of an undamped oscillator (\\(\\zeta=0\\)), and \\(\\zeta\\) is the damping ratio.</p> <p>The solution to the above harmonic oscillator is</p> \\[ x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)     e^{-\\zeta \\omega t}, \\] <p>where</p> \\[ \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}. \\] <p>A Simple Harmonic Oscillator (\\(\\zeta=0\\))</p> <p>In a one dimensional world, a mass \\(m\\), driven by a force \\(F=-kx\\), is described as</p> \\[ \\begin{align} F &amp;= - k x \\\\ F &amp;= m a \\end{align} \\] <p>The mass behaves like a simple harmonic oscillator.</p> <p>In general, the solution to a simple harmonic oscillator is</p> \\[ x(t) = A \\cos(\\omega t + \\phi), \\] <p>where \\(\\omega\\) is the angular frequency, \\(\\phi\\) is the initial phase, and \\(A\\) is the amplitude.</p> <p>To use this generator,</p> <pre><code>params = {\"omega\": omega}\n\nho = HarmonicOscillator(params=params)\n\ndf = ho(n_periods=1, n_samples_per_period=10)\n</code></pre> <p><code>df</code> will be a pandas dataframe with two columns: <code>t</code> and <code>x</code>.</p> <ol> <li> <p>Contributors to Wikimedia projects. Harmonic oscillator.         In: Wikipedia [Internet]. 18 Feb 2024 [cited 20 Feb 2024].         Available: https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator \u21a9</p> </li> <li> <p>Libretexts. 5.3: General Solution for the Damped Harmonic Oscillator. Libretexts. 13 Apr 2021.             Available: https://t.ly/cWTIo. Accessed 20 Feb 2024.\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>Dict[str, float]</code> <p>all the params that defines the harmonic oscillator.</p> required <code>initial_condition</code> <code>Optional[Dict[str, float]]</code> <p>the initial condition of the harmonic oscillator.</p> <code>{}</code> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class HarmonicOscillator:\n    r\"\"\"Generate time series data for a [harmonic oscillator](https://en.wikipedia.org/wiki/Harmonic_oscillator).\n\n    The equation for a general un-driven harmonic oscillator is[^wiki_ho][^libretext_ho]\n\n    $$\n    \\frac{\\mathrm d x^2}{\\mathrm d t^2} + 2\\zeta \\omega \\frac{\\mathrm d x}{\\mathrm dt} + \\omega^2 x = 0,\n    $$\n\n    where $x$ is the displacement, $\\omega$ is the angular frequency of an undamped oscillator ($\\zeta=0$),\n    and $\\zeta$ is the damping ratio.\n\n    [^wiki_ho]: Contributors to Wikimedia projects. Harmonic oscillator.\n                In: Wikipedia [Internet]. 18 Feb 2024 [cited 20 Feb 2024].\n                Available: https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator\n\n    [^libretext_ho]: Libretexts. 5.3: General Solution for the Damped Harmonic Oscillator. Libretexts. 13 Apr 2021.\n                    Available: https://t.ly/cWTIo. Accessed 20 Feb 2024.\n\n\n    The solution to the above harmonic oscillator is\n\n    $$\n    x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n        e^{-\\zeta \\omega t},\n    $$\n\n    where\n\n    $$\n    \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n    $$\n\n\n    !!! example \"A Simple Harmonic Oscillator ($\\zeta=0$)\"\n\n        In a one dimensional world, a mass $m$, driven by a force $F=-kx$, is described as\n\n        $$\n        \\begin{align}\n        F &amp;= - k x \\\\\n        F &amp;= m a\n        \\end{align}\n        $$\n\n        The mass behaves like a simple harmonic oscillator.\n\n        In general, the solution to a simple harmonic oscillator is\n\n        $$\n        x(t) = A \\cos(\\omega t + \\phi),\n        $$\n\n        where $\\omega$ is the angular frequency, $\\phi$ is the initial phase, and $A$ is the amplitude.\n\n\n    To use this generator,\n\n    ```python\n    params = {\"omega\": omega}\n\n    ho = HarmonicOscillator(params=params)\n\n    df = ho(n_periods=1, n_samples_per_period=10)\n    ```\n\n    `df` will be a pandas dataframe with two columns: `t` and `x`.\n\n    :param system: all the params that defines the harmonic oscillator.\n    :param initial_condition: the initial condition of the harmonic oscillator.\n    \"\"\"\n\n    def __init__(\n        self,\n        system: Dict[str, float],\n        initial_condition: Optional[Dict[str, float]] = {},\n    ):\n        self.system = HarmonicOscillatorSystem.model_validate(system)\n        self.initial_condition = HarmonicOscillatorIC.model_validate(initial_condition)\n\n    @cached_property\n    def definition(self) -&gt; Dict[str, float]:\n        \"\"\"model params and initial conditions defined as a dictionary.\"\"\"\n        return {\n            \"system\": self.system.model_dump(),\n            \"initial_condition\": self.initial_condition.model_dump(),\n        }\n\n    def _x_simple(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n        r\"\"\"Solution to simple harmonic oscillators:\n\n        $$\n        x(t) = x_0 \\cos(\\omega t).\n        $$\n        \"\"\"\n        return self.initial_condition.x0 * np.cos(self.system.omega * t)\n\n    def _x_under_damped(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n        r\"\"\"Solution to under damped harmonic oscillators:\n\n        $$\n        x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n        e^{-\\zeta \\omega t},\n        $$\n\n        where\n\n        $$\n        \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n        $$\n        \"\"\"\n        omega_damp = self.system.omega * np.sqrt(1 - self.system.zeta)\n        return (\n            self.initial_condition.x0 * np.cos(omega_damp * t)\n            + (\n                self.system.zeta * self.system.omega * self.initial_condition.x0\n                + self.initial_condition.v0\n            )\n            / omega_damp\n            * np.sin(omega_damp * t)\n        ) * np.exp(-self.system.zeta * self.system.omega * t)\n\n    def _x_critical_damped(\n        self, t: Union[float, np.ndarray]\n    ) -&gt; Union[float, np.ndarray]:\n        r\"\"\"Solution to critical damped harmonic oscillators:\n\n        $$\n        x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n        e^{-\\zeta \\omega t},\n        $$\n\n        where\n\n        $$\n        \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n        $$\n        \"\"\"\n        return self.initial_condition.x0 * np.exp(\n            -self.system.zeta * self.system.omega * t\n        )\n\n    def _x_over_damped(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n        r\"\"\"Solution to over harmonic oscillators:\n\n        $$\n        x(t) = \\left( x_0 \\cosh(\\Gamma t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Gamma} \\sinh(\\Gamma t) \\right)\n        e^{-\\zeta \\omega t},\n        $$\n\n        where\n\n        $$\n        \\Gamma = \\omega\\sqrt{ \\zeta^2 - 1 }.\n        $$\n        \"\"\"\n        gamma_damp = self.system.omega * np.sqrt(self.system.zeta - 1)\n\n        return (\n            self.initial_condition.x0 * np.cosh(gamma_damp * t)\n            + (\n                self.system.zeta * self.system.omega * self.initial_condition.x0\n                + self.initial_condition.v0\n            )\n            / gamma_damp\n            * np.sinh(gamma_damp * t)\n        ) * np.exp(-self.system.zeta * self.system.omega * t)\n\n    def __call__(self, n_periods: int, n_samples_per_period: int) -&gt; pd.DataFrame:\n        \"\"\"Generate time series data for the harmonic oscillator.\n\n        Returns a list of floats representing the displacement at each time step.\n\n        :param n_periods: Number of periods to generate.\n        :param n_samples_per_period: Number of samples per period.\n        \"\"\"\n        time_delta = self.system.period / n_samples_per_period\n        time_steps = np.arange(0, n_periods * n_samples_per_period) * time_delta\n\n        if self.system.type == \"simple\":\n            data = self._x_simple(time_steps)\n        elif self.system.type == \"under_damped\":\n            data = self._x_under_damped(time_steps)\n        elif self.system.type == \"over_damped\":\n            data = self._x_over_damped(time_steps)\n        elif self.system.type == \"critical_damped\":\n            data = self._x_critical_damped(time_steps)\n        else:\n            raise ValueError(f\"system type is not defined: {self.system.type}\")\n\n        return pd.DataFrame({\"t\": time_steps, \"x\": data})\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillator.definition","title":"<code>definition: Dict[str, float]</code>  <code>cached</code> <code>property</code>","text":"<p>model params and initial conditions defined as a dictionary.</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillator.__call__","title":"<code>__call__(n_periods, n_samples_per_period)</code>","text":"<p>Generate time series data for the harmonic oscillator.</p> <p>Returns a list of floats representing the displacement at each time step.</p> <p>Parameters:</p> Name Type Description Default <code>n_periods</code> <code>int</code> <p>Number of periods to generate.</p> required <code>n_samples_per_period</code> <code>int</code> <p>Number of samples per period.</p> required Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def __call__(self, n_periods: int, n_samples_per_period: int) -&gt; pd.DataFrame:\n    \"\"\"Generate time series data for the harmonic oscillator.\n\n    Returns a list of floats representing the displacement at each time step.\n\n    :param n_periods: Number of periods to generate.\n    :param n_samples_per_period: Number of samples per period.\n    \"\"\"\n    time_delta = self.system.period / n_samples_per_period\n    time_steps = np.arange(0, n_periods * n_samples_per_period) * time_delta\n\n    if self.system.type == \"simple\":\n        data = self._x_simple(time_steps)\n    elif self.system.type == \"under_damped\":\n        data = self._x_under_damped(time_steps)\n    elif self.system.type == \"over_damped\":\n        data = self._x_over_damped(time_steps)\n    elif self.system.type == \"critical_damped\":\n        data = self._x_critical_damped(time_steps)\n    else:\n        raise ValueError(f\"system type is not defined: {self.system.type}\")\n\n    return pd.DataFrame({\"t\": time_steps, \"x\": data})\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillator._x_critical_damped","title":"<code>_x_critical_damped(t)</code>","text":"<p>Solution to critical damped harmonic oscillators:</p> \\[ x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right) e^{-\\zeta \\omega t}, \\] <p>where</p> \\[ \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}. \\] Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def _x_critical_damped(\n    self, t: Union[float, np.ndarray]\n) -&gt; Union[float, np.ndarray]:\n    r\"\"\"Solution to critical damped harmonic oscillators:\n\n    $$\n    x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n    e^{-\\zeta \\omega t},\n    $$\n\n    where\n\n    $$\n    \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n    $$\n    \"\"\"\n    return self.initial_condition.x0 * np.exp(\n        -self.system.zeta * self.system.omega * t\n    )\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillator._x_over_damped","title":"<code>_x_over_damped(t)</code>","text":"<p>Solution to over harmonic oscillators:</p> \\[ x(t) = \\left( x_0 \\cosh(\\Gamma t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Gamma} \\sinh(\\Gamma t) \\right) e^{-\\zeta \\omega t}, \\] <p>where</p> \\[ \\Gamma = \\omega\\sqrt{ \\zeta^2 - 1 }. \\] Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def _x_over_damped(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n    r\"\"\"Solution to over harmonic oscillators:\n\n    $$\n    x(t) = \\left( x_0 \\cosh(\\Gamma t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Gamma} \\sinh(\\Gamma t) \\right)\n    e^{-\\zeta \\omega t},\n    $$\n\n    where\n\n    $$\n    \\Gamma = \\omega\\sqrt{ \\zeta^2 - 1 }.\n    $$\n    \"\"\"\n    gamma_damp = self.system.omega * np.sqrt(self.system.zeta - 1)\n\n    return (\n        self.initial_condition.x0 * np.cosh(gamma_damp * t)\n        + (\n            self.system.zeta * self.system.omega * self.initial_condition.x0\n            + self.initial_condition.v0\n        )\n        / gamma_damp\n        * np.sinh(gamma_damp * t)\n    ) * np.exp(-self.system.zeta * self.system.omega * t)\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillator._x_simple","title":"<code>_x_simple(t)</code>","text":"<p>Solution to simple harmonic oscillators:</p> \\[ x(t) = x_0 \\cos(\\omega t). \\] Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def _x_simple(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n    r\"\"\"Solution to simple harmonic oscillators:\n\n    $$\n    x(t) = x_0 \\cos(\\omega t).\n    $$\n    \"\"\"\n    return self.initial_condition.x0 * np.cos(self.system.omega * t)\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillator._x_under_damped","title":"<code>_x_under_damped(t)</code>","text":"<p>Solution to under damped harmonic oscillators:</p> \\[ x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right) e^{-\\zeta \\omega t}, \\] <p>where</p> \\[ \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}. \\] Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def _x_under_damped(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n    r\"\"\"Solution to under damped harmonic oscillators:\n\n    $$\n    x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n    e^{-\\zeta \\omega t},\n    $$\n\n    where\n\n    $$\n    \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n    $$\n    \"\"\"\n    omega_damp = self.system.omega * np.sqrt(1 - self.system.zeta)\n    return (\n        self.initial_condition.x0 * np.cos(omega_damp * t)\n        + (\n            self.system.zeta * self.system.omega * self.initial_condition.x0\n            + self.initial_condition.v0\n        )\n        / omega_damp\n        * np.sin(omega_damp * t)\n    ) * np.exp(-self.system.zeta * self.system.omega * t)\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorIC","title":"<code>HarmonicOscillatorIC</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The initial condition for a harmonic oscillator</p> <p>Attributes:</p> Name Type Description <code>x0</code> <code>float</code> <p>the initial displacement</p> <code>v0</code> <code>float</code> <p>the initial velocity</p> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class HarmonicOscillatorIC(BaseModel):\n    \"\"\"The initial condition for a harmonic oscillator\n\n    :cvar x0: the initial displacement\n    :cvar v0: the initial velocity\n    \"\"\"\n\n    x0: float = 1.0\n    v0: float = 0.0\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem","title":"<code>HarmonicOscillatorSystem</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The params for the harmonic oscillator</p> <p>Attributes:</p> Name Type Description <code>omega</code> <code>float</code> <p>angular frequency of the harmonic oscillator</p> <code>zeta</code> <code>float</code> <p>damping ratio</p> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class HarmonicOscillatorSystem(BaseModel):\n    \"\"\"The params for the harmonic oscillator\n\n    :cvar omega: angular frequency of the harmonic oscillator\n    :cvar zeta: damping ratio\n    \"\"\"\n\n    omega: float\n    zeta: float = 0.0\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def period(self) -&gt; float:\n        \"\"\"period of the oscillator\"\"\"\n        return 2 * np.pi / self.omega\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def frequency(self) -&gt; float:\n        \"\"\"frequency of the oscillator\"\"\"\n        return 1 / self.period\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def type(\n        self,\n    ) -&gt; Literal[\"simple\", \"under_damped\", \"critical_damped\", \"over_damped\"]:\n        \"\"\"which type of harmonic oscillators\"\"\"\n        if self.zeta == 0:\n            return \"simple\"\n        elif self.zeta &lt; 1:\n            return \"under_damped\"\n        elif self.zeta == 1:\n            return \"critical_damped\"\n        else:\n            return \"over_damped\"\n\n    @field_validator(\"zeta\")\n    @classmethod\n    def check_zeta_non_negative(cls, v: float) -&gt; float:\n        if v &lt; 0:\n            raise ValueError(f\"Value of zeta should be positive: {v=}\")\n\n        return v\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem.frequency","title":"<code>frequency: float</code>  <code>cached</code> <code>property</code>","text":"<p>frequency of the oscillator</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem.period","title":"<code>period: float</code>  <code>cached</code> <code>property</code>","text":"<p>period of the oscillator</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem.type","title":"<code>type: Literal['simple', 'under_damped', 'critical_damped', 'over_damped']</code>  <code>cached</code> <code>property</code>","text":"<p>which type of harmonic oscillators</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>We provide some tutorials to help you get started.</p>"},{"location":"tutorials/brownian_motion/","title":"Brownian Motion","text":"In\u00a0[1]: Copied! <pre>import plotly.express as px\n\nfrom hamilflow.models.brownian_motion import BrownianMotion\n</pre> import plotly.express as px  from hamilflow.models.brownian_motion import BrownianMotion In\u00a0[2]: Copied! <pre>bm_1d = BrownianMotion(\n    system={\n        \"sigma\": 1,\n        \"delta_t\": 1,\n    },\n    initial_condition={\"x0\": 0},\n)\n</pre> bm_1d = BrownianMotion(     system={         \"sigma\": 1,         \"delta_t\": 1,     },     initial_condition={\"x0\": 0}, ) <p>Call the model to generate 1000 steps.</p> In\u00a0[3]: Copied! <pre>df_1d = bm_1d(n_steps=1000)\n</pre> df_1d = bm_1d(n_steps=1000) In\u00a0[4]: Copied! <pre>px.line(df_1d, x=\"t\", y=\"y_0\")\n</pre> px.line(df_1d, x=\"t\", y=\"y_0\") In\u00a0[5]: Copied! <pre>bm_2d = BrownianMotion(\n    system={\n        \"sigma\": 1,\n        \"delta_t\": 1,\n    },\n    initial_condition={\"x0\": [0, 0]},\n)\n</pre> bm_2d = BrownianMotion(     system={         \"sigma\": 1,         \"delta_t\": 1,     },     initial_condition={\"x0\": [0, 0]}, ) <p>We call the model to generate 1000 steps.</p> In\u00a0[6]: Copied! <pre>df_2d = bm_2d(n_steps=500)\n</pre> df_2d = bm_2d(n_steps=500) In\u00a0[7]: Copied! <pre>(\n    px.scatter(df_2d, x=\"y_0\", y=\"y_1\", color=\"t\")\n    .update_traces(\n        mode=\"lines+markers\",\n        marker=dict(\n            size=2.5,\n        ),\n        line=dict(width=1),\n    )\n    .update_yaxes(\n        scaleanchor=\"x\",\n        scaleratio=1,\n    )\n)\n</pre> (     px.scatter(df_2d, x=\"y_0\", y=\"y_1\", color=\"t\")     .update_traces(         mode=\"lines+markers\",         marker=dict(             size=2.5,         ),         line=dict(width=1),     )     .update_yaxes(         scaleanchor=\"x\",         scaleratio=1,     ) ) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/brownian_motion/#brownian-motion","title":"Brownian Motion\u00b6","text":"<p>Brownian motion describes motion of small particles with stochastic forces applied to them. The math of Brownian motion can be modeled with Wiener process. In this tutorial, we take a simple form of the model and treat the stochastic forces as Gaussian.</p> <p>For consistency, we always use $\\mathbf x$ for displacement, and $t$ for steps. The model we are using is</p> <p>$$ \\begin{align} \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) + \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t}) \\end{align} $$</p> <p>Read more:</p> <ol> <li>Brownian motion and random walks. [cited 13 Mar 2024]. Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html</li> <li>Contributors to Wikimedia projects. Brownian motion. In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024]. Available: https://en.wikipedia.org/wiki/Brownian_motion</li> </ol> <p><code>hamilflow</code> implemented a Brownian motion model called <code>BrownianMotion</code>.</p>"},{"location":"tutorials/brownian_motion/#1d-brownian-motion","title":"1D Brownian Motion\u00b6","text":""},{"location":"tutorials/brownian_motion/#2d-brownian-motion","title":"2D Brownian Motion\u00b6","text":"<p>Our <code>BrownianMotion</code> model calculates the dimension of the space based on the dimension of the initial condition $x_0$. To create a 2D Brownian motion model, we need the initial condition to be length 2.</p>"},{"location":"tutorials/harmonic_oscillator/","title":"Harmonic Oscillators","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport plotly.express as px\n\nfrom hamilflow.models.harmonic_oscillator import HarmonicOscillator\n</pre> import pandas as pd import plotly.express as px  from hamilflow.models.harmonic_oscillator import HarmonicOscillator <pre>/tmp/ipykernel_1946/3199496368.py:1: DeprecationWarning: \nPyarrow will become a required dependency of pandas in the next major release of pandas (pandas 3.0),\n(to allow more performant data types, such as the Arrow string type, and better interoperability with other libraries)\nbut was not found to be installed on your system.\nIf this would cause problems for you,\nplease provide us feedback at https://github.com/pandas-dev/pandas/issues/54466\n        \n  import pandas as pd\n</pre> In\u00a0[2]: Copied! <pre>n_periods = 3\nn_samples_per_period = 200\n</pre> n_periods = 3 n_samples_per_period = 200 In\u00a0[3]: Copied! <pre>sho_omega = 0.5\n\nsho = HarmonicOscillator(system={\"omega\": sho_omega})\n</pre> sho_omega = 0.5  sho = HarmonicOscillator(system={\"omega\": sho_omega}) In\u00a0[4]: Copied! <pre>df_sho = sho(n_periods=n_periods, n_samples_per_period=n_samples_per_period)\ndf_sho.head()\n</pre> df_sho = sho(n_periods=n_periods, n_samples_per_period=n_samples_per_period) df_sho.head() Out[4]: t x 0 0.000000 1.000000 1 0.062832 0.999507 2 0.125664 0.998027 3 0.188496 0.995562 4 0.251327 0.992115 In\u00a0[5]: Copied! <pre>px.line(\n    df_sho,\n    x=\"t\",\n    y=\"x\",\n    title=rf\"Simple Harmonic Oscillator (omega = {sho_omega})\",\n    labels={\n        \"x\": r\"Displacement $x(t)$\",\n        \"t\": r\"$t$\",\n    },\n)\n</pre> px.line(     df_sho,     x=\"t\",     y=\"x\",     title=rf\"Simple Harmonic Oscillator (omega = {sho_omega})\",     labels={         \"x\": r\"Displacement $x(t)$\",         \"t\": r\"$t$\",     }, ) In\u00a0[6]: Copied! <pre>dho_systems = {\n    \"Underdamped\": {\"omega\": 0.5, \"zeta\": 0.2},\n    \"Critical Damped\": {\"omega\": 0.5, \"zeta\": 1},\n    \"Overdamped\": {\n        \"omega\": 0.5,\n        \"zeta\": 1.2,\n    },\n}\n\ndfs_dho = []\n\nfor s_name, s in dho_systems.items():\n\n    dfs_dho.append(\n        HarmonicOscillator(system=s)(\n            n_periods=n_periods, n_samples_per_period=n_samples_per_period\n        ).assign(system=rf\"{s_name} (omega = {s.get('omega')}, zeta = {s.get('zeta')})\")\n    )\n\nfig = px.line(\n    pd.concat(dfs_dho),\n    x=\"t\",\n    y=\"x\",\n    color=\"system\",\n    title=rf\"Damped Harmonic Oscillator\",\n    labels={\n        \"x\": r\"Displacement $x(t)$\",\n        \"t\": r\"$t$\",\n    },\n)\nfig.update_layout(legend={\"yanchor\": \"top\", \"y\": -0.2, \"xanchor\": \"left\", \"x\": 0})\n</pre> dho_systems = {     \"Underdamped\": {\"omega\": 0.5, \"zeta\": 0.2},     \"Critical Damped\": {\"omega\": 0.5, \"zeta\": 1},     \"Overdamped\": {         \"omega\": 0.5,         \"zeta\": 1.2,     }, }  dfs_dho = []  for s_name, s in dho_systems.items():      dfs_dho.append(         HarmonicOscillator(system=s)(             n_periods=n_periods, n_samples_per_period=n_samples_per_period         ).assign(system=rf\"{s_name} (omega = {s.get('omega')}, zeta = {s.get('zeta')})\")     )  fig = px.line(     pd.concat(dfs_dho),     x=\"t\",     y=\"x\",     color=\"system\",     title=rf\"Damped Harmonic Oscillator\",     labels={         \"x\": r\"Displacement $x(t)$\",         \"t\": r\"$t$\",     }, ) fig.update_layout(legend={\"yanchor\": \"top\", \"y\": -0.2, \"xanchor\": \"left\", \"x\": 0}) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/harmonic_oscillator/#harmonic-oscillators","title":"Harmonic Oscillators\u00b6","text":"<p>In this tutorial, we demo how to generate data of harmonic oscillators.</p>"},{"location":"tutorials/harmonic_oscillator/#simple-harmonic-oscillator","title":"Simple Harmonic Oscillator\u00b6","text":""},{"location":"tutorials/harmonic_oscillator/#damped-harmonic-oscillator","title":"Damped Harmonic Oscillator\u00b6","text":""}]}