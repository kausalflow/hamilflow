{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation for <code>hamilflow</code>","text":"<p>Generating dataset for physical systems.</p>"},{"location":"#development","title":"Development","text":"<p>We use <code>poetry</code> to manage our python environment. Use</p> <pre><code>poetry install\n</code></pre> <p>to install the requirements. Or run</p> <pre><code>poetry install --with test\n</code></pre> <p>to install the base environment and test environment for development.</p> <p>If this is the first you clone the repo and committing code, run</p> <pre><code>pre-commit install\n</code></pre> <p>first.</p>"},{"location":"changelog/","title":"hamilflow Changelog","text":""},{"location":"changelog/#010-2024-03-21","title":"0.1.0 (2024-03-21)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>model: add brownian motion (#23)</li> <li>ops: #18 use commitizen (#21)</li> </ul>"},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>docs: fix docstrings for pydantic models cvar (#27)</li> </ul>"},{"location":"changelog/#2024-02-18-001","title":"2024-02-18, 0.0.1","text":"<p>Setting up repository.</p>"},{"location":"references/","title":"References","text":""},{"location":"references/models/brownian_motion/","title":"Brownian Motion","text":""},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotion","title":"<code>BrownianMotion</code>","text":"<p>Brownian motion describes motion of small particles with stochastic forces applied to them. The math of Brownian motion can be modeled with Wiener process.</p> <p>For consistency, we always use \\(\\mathbf x\\) for displacement, and \\(t\\) for steps. The model we are using is</p> \\[ \\begin{align} \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) + \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t}) \\end{align} \\] <p>References:</p> <ol> <li>Brownian motion and random walks. [cited 13 Mar 2024].     Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html</li> <li>Contributors to Wikimedia projects. Brownian motion.     In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024].     Available: https://en.wikipedia.org/wiki/Brownian_motion</li> </ol> <p>1D Brownian Motion</p> <p>The dimsion of our Brownian motion is specified by the dimension of the initial condition.</p> <p>To simulate a 1D Browian motion, we define the system and initial condition:</p> <pre><code>system = {\n    \"sigma\": 1,\n    \"delta_t\": 1,\n}\n\ninitial_condition = {\n    \"x0\": 0\n}\n</code></pre> <p>The Brownian motion can be simulated using</p> <pre><code>bm = BrownianMotion(system=system, initial_condition=initial_condition)\n\nbm(n_steps=100)\n</code></pre> <p>2D Brownian Motion</p> <p>To simulate a 2D Browian motion,</p> <pre><code>system = {\n    \"sigma\": 1,\n    \"delta_t\": 1,\n}\n\ninitial_condition = {\n    \"x0\": [0, 0]\n}\n\nbm = BrownianMotion(system=system, initial_condition=initial_condition)\n\nbm(n_steps=100)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>Dict[str, float]</code> <p>the Brownian motion system definition</p> required <code>initial_condition</code> <code>Optional[Dict[str, float]]</code> <p>the initial condition for the simulation</p> <code>{}</code> Source code in <code>hamilflow/models/brownian_motion.py</code> <pre><code>class BrownianMotion:\n    r\"\"\"Brownian motion describes motion of small particles\n    with stochastic forces applied to them.\n    The math of Brownian motion can be modeled\n    with Wiener process.\n\n    For consistency, we always use\n    $\\mathbf x$ for displacement, and\n    $t$ for steps. The model we are using is\n\n    $$\n    \\begin{align}\n    \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) +\n    \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t})\n    \\end{align}\n    $$\n\n    References:\n\n    1. Brownian motion and random walks. [cited 13 Mar 2024].\n        Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html\n    2. Contributors to Wikimedia projects. Brownian motion.\n        In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024].\n        Available: https://en.wikipedia.org/wiki/Brownian_motion\n\n\n    !!! example \"1D Brownian Motion\"\n\n        The dimsion of our Brownian motion is specified by\n        the dimension of the initial condition.\n\n        To simulate a 1D Browian motion, we define the system and initial condition:\n\n        ```python\n        system = {\n            \"sigma\": 1,\n            \"delta_t\": 1,\n        }\n\n        initial_condition = {\n            \"x0\": 0\n        }\n        ```\n\n        The Brownian motion can be simulated using\n\n        ```python\n        bm = BrownianMotion(system=system, initial_condition=initial_condition)\n\n        bm(n_steps=100)\n        ```\n\n    !!! example \"2D Brownian Motion\"\n\n        To simulate a 2D Browian motion,\n\n        ```python\n        system = {\n            \"sigma\": 1,\n            \"delta_t\": 1,\n        }\n\n        initial_condition = {\n            \"x0\": [0, 0]\n        }\n\n        bm = BrownianMotion(system=system, initial_condition=initial_condition)\n\n        bm(n_steps=100)\n        ```\n\n    :param system: the Brownian motion system definition\n    :param initial_condition: the initial condition for the simulation\n    \"\"\"\n\n    def __init__(\n        self,\n        system: Dict[str, float],\n        initial_condition: Optional[Dict[str, float]] = {},\n    ):\n        self.system = BrownianMotionSystem.model_validate(system)\n        self.initial_condition = BrownianMotionIC.model_validate(initial_condition)\n\n    @property\n    def dim(self) -&gt; int:\n        \"\"\"Dimension of the Brownian motion\"\"\"\n        return self.initial_condition.x0.size\n\n    @property\n    def _axis_names(self) -&gt; List[str]:\n        return [f\"y_{i}\" for i in range(self.dim)]\n\n    def _trajectory(self, n_new_steps: int, seed: int) -&gt; np.ndarray:\n        \"\"\"The trajectory of the particle.\n\n        We first compute the delta displacement in each step.\n        With the displacement at each step, we perform a cumsum\n        including the initial coordinate to get the displacement at each step.\n\n        :param n_new_steps: number of new steps to simulate, excluding the initial step.\n        :param seed: seed for the random generator.\n        \"\"\"\n        step_history = sp.stats.norm.rvs(\n            size=(n_new_steps, self.dim) if self.dim &gt; 1 else n_new_steps,\n            scale=self.system.gaussian_scale,\n            random_state=np.random.RandomState(seed=seed),\n        )\n\n        step_history = np.concatenate(\n            (np.expand_dims(self.initial_condition.x0, axis=0), step_history)\n        )\n\n        trajectory = np.cumsum(step_history, axis=0)\n\n        return trajectory\n\n    def __call__(self, n_steps: int, seed: int = 42) -&gt; pd.DataFrame:\n        \"\"\"Simulate the coordinates of the particle\n\n        :param n_steps: total number of steps to be simulated, including the inital step.\n        :param seed: random generator seed for the stochastic process.\n            Use it to reproduce results.\n        \"\"\"\n        trajectory = self._trajectory(n_new_steps=n_steps - 1, seed=seed)\n\n        df = pd.DataFrame(trajectory, columns=self._axis_names)\n\n        df[\"t\"] = np.arange(0, n_steps) * self.system.delta_t\n\n        return df\n</code></pre>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotion.dim","title":"<code>dim: int</code>  <code>property</code>","text":"<p>Dimension of the Brownian motion</p>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotion.__call__","title":"<code>__call__(n_steps, seed=42)</code>","text":"<p>Simulate the coordinates of the particle</p> <p>Parameters:</p> Name Type Description Default <code>n_steps</code> <code>int</code> <p>total number of steps to be simulated, including the inital step.</p> required <code>seed</code> <code>int</code> <p>random generator seed for the stochastic process. Use it to reproduce results.</p> <code>42</code> Source code in <code>hamilflow/models/brownian_motion.py</code> <pre><code>def __call__(self, n_steps: int, seed: int = 42) -&gt; pd.DataFrame:\n    \"\"\"Simulate the coordinates of the particle\n\n    :param n_steps: total number of steps to be simulated, including the inital step.\n    :param seed: random generator seed for the stochastic process.\n        Use it to reproduce results.\n    \"\"\"\n    trajectory = self._trajectory(n_new_steps=n_steps - 1, seed=seed)\n\n    df = pd.DataFrame(trajectory, columns=self._axis_names)\n\n    df[\"t\"] = np.arange(0, n_steps) * self.system.delta_t\n\n    return df\n</code></pre>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotion._trajectory","title":"<code>_trajectory(n_new_steps, seed)</code>","text":"<p>The trajectory of the particle.</p> <p>We first compute the delta displacement in each step. With the displacement at each step, we perform a cumsum including the initial coordinate to get the displacement at each step.</p> <p>Parameters:</p> Name Type Description Default <code>n_new_steps</code> <code>int</code> <p>number of new steps to simulate, excluding the initial step.</p> required <code>seed</code> <code>int</code> <p>seed for the random generator.</p> required Source code in <code>hamilflow/models/brownian_motion.py</code> <pre><code>def _trajectory(self, n_new_steps: int, seed: int) -&gt; np.ndarray:\n    \"\"\"The trajectory of the particle.\n\n    We first compute the delta displacement in each step.\n    With the displacement at each step, we perform a cumsum\n    including the initial coordinate to get the displacement at each step.\n\n    :param n_new_steps: number of new steps to simulate, excluding the initial step.\n    :param seed: seed for the random generator.\n    \"\"\"\n    step_history = sp.stats.norm.rvs(\n        size=(n_new_steps, self.dim) if self.dim &gt; 1 else n_new_steps,\n        scale=self.system.gaussian_scale,\n        random_state=np.random.RandomState(seed=seed),\n    )\n\n    step_history = np.concatenate(\n        (np.expand_dims(self.initial_condition.x0, axis=0), step_history)\n    )\n\n    trajectory = np.cumsum(step_history, axis=0)\n\n    return trajectory\n</code></pre>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotionIC","title":"<code>BrownianMotionIC</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The initial condition for a Brownian motion</p> <p>Attributes:</p> Name Type Description <code>x0</code> <code>Union[float, int, List[Union[float, int]]]</code> <p>initial displacement of the particle, the diminsion of this initial condition determines the dimension of the model too.</p> Source code in <code>hamilflow/models/brownian_motion.py</code> <pre><code>class BrownianMotionIC(BaseModel):\n    \"\"\"The initial condition for a Brownian motion\n\n    :cvar x0: initial displacement of the particle,\n        the diminsion of this initial condition determines\n        the dimension of the model too.\n    \"\"\"\n\n    x0: Union[float, int, List[Union[float, int]]] = 1.0\n\n    @field_validator(\"x0\")\n    @classmethod\n    def check_x0_types(cls, v: Union[float, int, list]) -&gt; np.ndarray:\n        if not isinstance(v, (float, int, list)):\n            raise ValueError(f\"Value of x0 should be int/float/list of int/float: {v=}\")\n\n        return np.asarray(v)\n</code></pre>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotionSystem","title":"<code>BrownianMotionSystem</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Definition of the Brownian Motion system</p> <p>For consistency, we always use \\(\\mathbf x\\) for displacement, and \\(t\\) for steps. The model we are using is</p> \\[ \\begin{align} \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) + \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t}) \\end{align} \\] <p>References:</p> <ol> <li>Brownian motion and random walks. [cited 13 Mar 2024].     Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html</li> <li>Contributors to Wikimedia projects. Brownian motion.     In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024].     Available: https://en.wikipedia.org/wiki/Brownian_motion</li> </ol> <p>Attributes:</p> Name Type Description <code>sigma</code> <code>float</code> <p>base standard deviation to be used to compute the variance</p> <code>delta_t</code> <code>float</code> <p>time granunality of the motion</p> Source code in <code>hamilflow/models/brownian_motion.py</code> <pre><code>class BrownianMotionSystem(BaseModel):\n    r\"\"\"Definition of the Brownian Motion system\n\n    For consistency, we always use\n    $\\mathbf x$ for displacement, and\n    $t$ for steps. The model we are using is\n\n    $$\n    \\begin{align}\n    \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) +\n    \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t})\n    \\end{align}\n    $$\n\n    References:\n\n    1. Brownian motion and random walks. [cited 13 Mar 2024].\n        Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html\n    2. Contributors to Wikimedia projects. Brownian motion.\n        In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024].\n        Available: https://en.wikipedia.org/wiki/Brownian_motion\n\n    :cvar sigma: base standard deviation\n        to be used to compute the variance\n    :cvar delta_t: time granunality of the motion\n    \"\"\"\n\n    sigma: float = Field(ge=0)\n    delta_t: float = Field(ge=0, default=1.0)\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def gaussian_scale(self) -&gt; float:\n        \"\"\"The scale (standard deviation) of the Gaussian term\n        in Brownian motion\n        \"\"\"\n        return self.sigma**2 * self.delta_t\n</code></pre>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotionSystem.gaussian_scale","title":"<code>gaussian_scale: float</code>  <code>cached</code> <code>property</code>","text":"<p>The scale (standard deviation) of the Gaussian term in Brownian motion</p>"},{"location":"references/models/central_field/","title":"Brownian Motion","text":""},{"location":"references/models/central_field/#hamilflow.models.central_field.CentralField2D","title":"<code>CentralField2D</code>","text":"<p>Central field motion in two dimensional space.</p> <p>Inverse Sqare Law</p> <p>We only consider central field of the form \\(-\\frac{\\alpha}{r}\\).</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>Dict[str, float]</code> <p>the Central field motion system definition</p> required <code>initial_condition</code> <code>Optional[Dict[str, float]]</code> <p>the initial condition for the simulation</p> <code>{}</code> Source code in <code>hamilflow/models/central_field.py</code> <pre><code>class CentralField2D:\n    r\"\"\"Central field motion in two dimensional space.\n\n    !!! info \"Inverse Sqare Law\"\n\n        We only consider central field of the form $-\\frac{\\alpha}{r}$.\n\n    :param system: the Central field motion system definition\n    :param initial_condition: the initial condition for the simulation\n    \"\"\"\n\n    def __init__(\n        self,\n        system: Dict[str, float],\n        initial_condition: Optional[Dict[str, float]] = {},\n    ):\n        self.system = CentralField2DSystem.model_validate(system)\n        self.initial_condition = CentralField2DIC.model_validate(initial_condition)\n\n    @cached_property\n    def _angular_momentum(self) -&gt; float:\n        \"\"\"computes the angular momentum of the motion. Since the angular momentum is\n        conserved, it doesn't change through time.\n        \"\"\"\n        return (\n            self.system.mass\n            * self.initial_condition.r_0**2\n            * self.initial_condition.v_phi_0\n        )\n\n    @cached_property\n    def _energy(self) -&gt; float:\n        \"\"\"computes the total energy\"\"\"\n        v_r_0 = self.initial_condition.v_r_0\n        v_phi_0 = self.initial_condition.v_phi_0\n        r_0 = self.initial_condition.r_0\n\n        potential_energy = -1 * self.system.alpha / r_0\n\n        return (\n            0.5 * self.system.mass * (v_r_0**2 + r_0**2 * v_phi_0**2) + potential_energy\n        )\n</code></pre>"},{"location":"references/models/central_field/#hamilflow.models.central_field.CentralField2D._angular_momentum","title":"<code>_angular_momentum: float</code>  <code>cached</code> <code>property</code>","text":"<p>computes the angular momentum of the motion. Since the angular momentum is conserved, it doesn't change through time.</p>"},{"location":"references/models/central_field/#hamilflow.models.central_field.CentralField2D._energy","title":"<code>_energy: float</code>  <code>cached</code> <code>property</code>","text":"<p>computes the total energy</p>"},{"location":"references/models/central_field/#hamilflow.models.central_field.CentralField2DIC","title":"<code>CentralField2DIC</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The initial condition for a Brownian motion</p> <p>Attributes:</p> Name Type Description <code>r_0</code> <code>float</code> <p>the initial radial coordinate</p> <code>phi_0</code> <code>float</code> <p>the initial phase</p> <code>v_r_0</code> <code>float</code> <p>the initial radial velocity</p> <code>v_phi_0</code> <code>float</code> <p>the initial phase velocity</p> Source code in <code>hamilflow/models/central_field.py</code> <pre><code>class CentralField2DIC(BaseModel):\n    \"\"\"The initial condition for a Brownian motion\n\n    :cvar r_0: the initial radial coordinate\n    :cvar phi_0: the initial phase\n    :cvar v_r_0: the initial radial velocity\n    :cvar v_phi_0: the initial phase velocity\n    \"\"\"\n\n    r_0: float = Field(gt=0, default=1.0)\n    phi_0: float = Field(ge=0, default=0.0)\n    v_r_0: float = 1.0\n    v_phi_0: float = 1.0\n</code></pre>"},{"location":"references/models/central_field/#hamilflow.models.central_field.CentralField2DSystem","title":"<code>CentralField2DSystem</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Definition of the central field system</p> <p>Potential:</p> \\[ V(r) = - \\frac{\\alpha}{r}. \\] <p>For reference, if an object is orbiting our Sun, the constant \\(\\alpha = G M_{\\odot} ~ 1.327\u00d710^20 m^3/s^2\\) in SI, which is also called 1 TCB, or 1 solar mass parameter. For computational stability, we recommend using TCB as the unit instead of the large SI values.</p> <p>Units</p> <p>When specifying the parameters of the system, be ware of the consistency of the units.</p> <p>Attributes:</p> Name Type Description <code>alpha</code> <code>float</code> <p>the proportional constant of the potential energy.</p> <code>mass</code> <code>float</code> <p>the mass of the orbiting object</p> Source code in <code>hamilflow/models/central_field.py</code> <pre><code>class CentralField2DSystem(BaseModel):\n    r\"\"\"Definition of the central field system\n\n    Potential:\n\n    $$\n    V(r) = - \\frac{\\alpha}{r}.\n    $$\n\n    For reference, if an object is orbiting our Sun, the constant $\\alpha = G M_{\\odot} ~ 1.327\u00d710^20 m^3/s^2$ in SI,\n    which is also called 1 TCB, or 1 solar mass parameter. For computational stability, we recommend using\n    TCB as the unit instead of the large SI values.\n\n    !!! note \"Units\"\n\n        When specifying the parameters of the system, be ware of the consistency of the units.\n\n    :cvar alpha: the proportional constant of the potential energy.\n    :cvar mass: the mass of the orbiting object\n    \"\"\"\n\n    alpha: float = Field(gt=0, default=1)\n    mass: float = Field(gt=0, default=1)\n</code></pre>"},{"location":"references/models/harmonic_oscillator/","title":"Harmonic Oscillator","text":""},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.DampedHarmonicOscillator","title":"<code>DampedHarmonicOscillator</code>","text":"<p>             Bases: <code>HarmonicOscillatorBase</code></p> <p>Generate time series data for a damped harmonic oscillator.</p> <p>The equation for a general un-driven harmonic oscillator is<sup>1</sup><sup>2</sup></p> \\[ \\frac{\\mathrm d x^2}{\\mathrm d t^2} + 2\\zeta \\omega \\frac{\\mathrm d x}{\\mathrm dt} + \\omega^2 x = 0, \\] <p>where \\(x\\) is the displacement, \\(\\omega\\) is the angular frequency of an undamped oscillator (\\(\\zeta=0\\)), and \\(\\zeta\\) is the damping ratio.</p> <p>The solution to the above harmonic oscillator is</p> \\[ x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)     e^{-\\zeta \\omega t}, \\] <p>where</p> \\[ \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}. \\] <p>To use this generator,</p> <pre><code>params = {\"omega\": omega, \"zeta\"=0.2}\n\nho = DampedHarmonicOscillator(params=params)\n\ndf = ho(n_periods=1, n_samples_per_period=10)\n</code></pre> <p><code>df</code> will be a pandas dataframe with two columns: <code>t</code> and <code>x</code>.</p> <ol> <li> <p>Contributors to Wikimedia projects. Harmonic oscillator.         In: Wikipedia [Internet]. 18 Feb 2024 [cited 20 Feb 2024].         Available: https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator \u21a9</p> </li> <li> <p>Libretexts. 5.3: General Solution for the Damped Harmonic Oscillator. Libretexts. 13 Apr 2021.             Available: https://t.ly/cWTIo. Accessed 20 Feb 2024.\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>Dict[str, float]</code> <p>all the params that defines the harmonic oscillator.</p> required <code>initial_condition</code> <code>Optional[Dict[str, float]]</code> <p>the initial condition of the harmonic oscillator.</p> <code>{}</code> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class DampedHarmonicOscillator(HarmonicOscillatorBase):\n    r\"\"\"Generate time series data for a [damped harmonic oscillator](https://en.wikipedia.org/wiki/Harmonic_oscillator).\n\n    The equation for a general un-driven harmonic oscillator is[^wiki_ho][^libretext_ho]\n\n    $$\n    \\frac{\\mathrm d x^2}{\\mathrm d t^2} + 2\\zeta \\omega \\frac{\\mathrm d x}{\\mathrm dt} + \\omega^2 x = 0,\n    $$\n\n    where $x$ is the displacement, $\\omega$ is the angular frequency of an undamped oscillator ($\\zeta=0$),\n    and $\\zeta$ is the damping ratio.\n\n    [^wiki_ho]: Contributors to Wikimedia projects. Harmonic oscillator.\n                In: Wikipedia [Internet]. 18 Feb 2024 [cited 20 Feb 2024].\n                Available: https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator\n\n    [^libretext_ho]: Libretexts. 5.3: General Solution for the Damped Harmonic Oscillator. Libretexts. 13 Apr 2021.\n                    Available: https://t.ly/cWTIo. Accessed 20 Feb 2024.\n\n\n    The solution to the above harmonic oscillator is\n\n    $$\n    x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n        e^{-\\zeta \\omega t},\n    $$\n\n    where\n\n    $$\n    \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n    $$\n\n    To use this generator,\n\n    ```python\n    params = {\"omega\": omega, \"zeta\"=0.2}\n\n    ho = DampedHarmonicOscillator(params=params)\n\n    df = ho(n_periods=1, n_samples_per_period=10)\n    ```\n\n    `df` will be a pandas dataframe with two columns: `t` and `x`.\n\n    :param system: all the params that defines the harmonic oscillator.\n    :param initial_condition: the initial condition of the harmonic oscillator.\n    \"\"\"\n\n    def __init__(\n        self,\n        system: Dict[str, float],\n        initial_condition: Optional[Dict[str, float]] = {},\n    ):\n        super().__init__(system, initial_condition)\n        if self.system.type == \"simple\":\n            raise ValueError(\n                f\"System is not a Damped Harmonic Oscillator: {self.system}\\n\"\n                f\"This is a simple harmonic oscillator, use `SimpleHarmonicOscillator`.\"\n            )\n\n    def _x_under_damped(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n        r\"\"\"Solution to under damped harmonic oscillators:\n\n        $$\n        x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n        e^{-\\zeta \\omega t},\n        $$\n\n        where\n\n        $$\n        \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n        $$\n        \"\"\"\n        omega_damp = self.system.omega * np.sqrt(1 - self.system.zeta)\n        return (\n            self.initial_condition.x0 * np.cos(omega_damp * t)\n            + (\n                self.system.zeta * self.system.omega * self.initial_condition.x0\n                + self.initial_condition.v0\n            )\n            / omega_damp\n            * np.sin(omega_damp * t)\n        ) * np.exp(-self.system.zeta * self.system.omega * t)\n\n    def _x_critical_damped(\n        self, t: Union[float, np.ndarray]\n    ) -&gt; Union[float, np.ndarray]:\n        r\"\"\"Solution to critical damped harmonic oscillators:\n\n        $$\n        x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n        e^{-\\zeta \\omega t},\n        $$\n\n        where\n\n        $$\n        \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n        $$\n        \"\"\"\n        return self.initial_condition.x0 * np.exp(\n            -self.system.zeta * self.system.omega * t\n        )\n\n    def _x_over_damped(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n        r\"\"\"Solution to over harmonic oscillators:\n\n        $$\n        x(t) = \\left( x_0 \\cosh(\\Gamma t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Gamma} \\sinh(\\Gamma t) \\right)\n        e^{-\\zeta \\omega t},\n        $$\n\n        where\n\n        $$\n        \\Gamma = \\omega\\sqrt{ \\zeta^2 - 1 }.\n        $$\n        \"\"\"\n        gamma_damp = self.system.omega * np.sqrt(self.system.zeta - 1)\n\n        return (\n            self.initial_condition.x0 * np.cosh(gamma_damp * t)\n            + (\n                self.system.zeta * self.system.omega * self.initial_condition.x0\n                + self.initial_condition.v0\n            )\n            / gamma_damp\n            * np.sinh(gamma_damp * t)\n        ) * np.exp(-self.system.zeta * self.system.omega * t)\n\n    def _x(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n        r\"\"\"Solution to damped harmonic oscillators.\"\"\"\n        if self.system.type == \"under_damped\":\n            x = self._x_under_damped(t)\n        elif self.system.type == \"over_damped\":\n            x = self._x_over_damped(t)\n        elif self.system.type == \"critical_damped\":\n            x = self._x_critical_damped(t)\n        else:\n            raise ValueError(\n                \"System type is not damped harmonic oscillator: {self.system.type}\"\n            )\n\n        return x\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.DampedHarmonicOscillator._x","title":"<code>_x(t)</code>","text":"<p>Solution to damped harmonic oscillators.</p> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def _x(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n    r\"\"\"Solution to damped harmonic oscillators.\"\"\"\n    if self.system.type == \"under_damped\":\n        x = self._x_under_damped(t)\n    elif self.system.type == \"over_damped\":\n        x = self._x_over_damped(t)\n    elif self.system.type == \"critical_damped\":\n        x = self._x_critical_damped(t)\n    else:\n        raise ValueError(\n            \"System type is not damped harmonic oscillator: {self.system.type}\"\n        )\n\n    return x\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.DampedHarmonicOscillator._x_critical_damped","title":"<code>_x_critical_damped(t)</code>","text":"<p>Solution to critical damped harmonic oscillators:</p> \\[ x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right) e^{-\\zeta \\omega t}, \\] <p>where</p> \\[ \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}. \\] Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def _x_critical_damped(\n    self, t: Union[float, np.ndarray]\n) -&gt; Union[float, np.ndarray]:\n    r\"\"\"Solution to critical damped harmonic oscillators:\n\n    $$\n    x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n    e^{-\\zeta \\omega t},\n    $$\n\n    where\n\n    $$\n    \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n    $$\n    \"\"\"\n    return self.initial_condition.x0 * np.exp(\n        -self.system.zeta * self.system.omega * t\n    )\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.DampedHarmonicOscillator._x_over_damped","title":"<code>_x_over_damped(t)</code>","text":"<p>Solution to over harmonic oscillators:</p> \\[ x(t) = \\left( x_0 \\cosh(\\Gamma t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Gamma} \\sinh(\\Gamma t) \\right) e^{-\\zeta \\omega t}, \\] <p>where</p> \\[ \\Gamma = \\omega\\sqrt{ \\zeta^2 - 1 }. \\] Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def _x_over_damped(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n    r\"\"\"Solution to over harmonic oscillators:\n\n    $$\n    x(t) = \\left( x_0 \\cosh(\\Gamma t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Gamma} \\sinh(\\Gamma t) \\right)\n    e^{-\\zeta \\omega t},\n    $$\n\n    where\n\n    $$\n    \\Gamma = \\omega\\sqrt{ \\zeta^2 - 1 }.\n    $$\n    \"\"\"\n    gamma_damp = self.system.omega * np.sqrt(self.system.zeta - 1)\n\n    return (\n        self.initial_condition.x0 * np.cosh(gamma_damp * t)\n        + (\n            self.system.zeta * self.system.omega * self.initial_condition.x0\n            + self.initial_condition.v0\n        )\n        / gamma_damp\n        * np.sinh(gamma_damp * t)\n    ) * np.exp(-self.system.zeta * self.system.omega * t)\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.DampedHarmonicOscillator._x_under_damped","title":"<code>_x_under_damped(t)</code>","text":"<p>Solution to under damped harmonic oscillators:</p> \\[ x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right) e^{-\\zeta \\omega t}, \\] <p>where</p> \\[ \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}. \\] Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def _x_under_damped(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n    r\"\"\"Solution to under damped harmonic oscillators:\n\n    $$\n    x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n    e^{-\\zeta \\omega t},\n    $$\n\n    where\n\n    $$\n    \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n    $$\n    \"\"\"\n    omega_damp = self.system.omega * np.sqrt(1 - self.system.zeta)\n    return (\n        self.initial_condition.x0 * np.cos(omega_damp * t)\n        + (\n            self.system.zeta * self.system.omega * self.initial_condition.x0\n            + self.initial_condition.v0\n        )\n        / omega_damp\n        * np.sin(omega_damp * t)\n    ) * np.exp(-self.system.zeta * self.system.omega * t)\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorBase","title":"<code>HarmonicOscillatorBase</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class to generate time series data for a harmonic oscillator.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>Dict[str, float]</code> <p>all the params that defines the harmonic oscillator.</p> required <code>initial_condition</code> <code>Optional[Dict[str, float]]</code> <p>the initial condition of the harmonic oscillator.</p> <code>{}</code> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class HarmonicOscillatorBase(ABC):\n    r\"\"\"Base class to generate time series data\n    for a [harmonic oscillator](https://en.wikipedia.org/wiki/Harmonic_oscillator).\n\n    :param system: all the params that defines the harmonic oscillator.\n    :param initial_condition: the initial condition of the harmonic oscillator.\n    \"\"\"\n\n    def __init__(\n        self,\n        system: Dict[str, float],\n        initial_condition: Optional[Dict[str, float]] = {},\n    ):\n        self.system = HarmonicOscillatorSystem.model_validate(system)\n        self.initial_condition = HarmonicOscillatorIC.model_validate(initial_condition)\n\n    @cached_property\n    def definition(self) -&gt; Dict[str, float]:\n        \"\"\"model params and initial conditions defined as a dictionary.\"\"\"\n        return {\n            \"system\": self.system.model_dump(),\n            \"initial_condition\": self.initial_condition.model_dump(),\n        }\n\n    @abstractmethod\n    def _x(self, t: ArrayLike) -&gt; ArrayLike:\n        r\"\"\"Solution to simple harmonic oscillators.\"\"\"\n        ...\n\n    def __call__(self, n_periods: int, n_samples_per_period: int) -&gt; pd.DataFrame:\n        \"\"\"Generate time series data for the harmonic oscillator.\n\n        Returns a list of floats representing the displacement at each time step.\n\n        :param n_periods: Number of periods to generate.\n        :param n_samples_per_period: Number of samples per period.\n        \"\"\"\n        time_delta = self.system.period / n_samples_per_period\n        time_steps = np.arange(0, n_periods * n_samples_per_period) * time_delta\n\n        data = self._x(time_steps)\n\n        return pd.DataFrame({\"t\": time_steps, \"x\": data})\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorBase.definition","title":"<code>definition: Dict[str, float]</code>  <code>cached</code> <code>property</code>","text":"<p>model params and initial conditions defined as a dictionary.</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorBase.__call__","title":"<code>__call__(n_periods, n_samples_per_period)</code>","text":"<p>Generate time series data for the harmonic oscillator.</p> <p>Returns a list of floats representing the displacement at each time step.</p> <p>Parameters:</p> Name Type Description Default <code>n_periods</code> <code>int</code> <p>Number of periods to generate.</p> required <code>n_samples_per_period</code> <code>int</code> <p>Number of samples per period.</p> required Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def __call__(self, n_periods: int, n_samples_per_period: int) -&gt; pd.DataFrame:\n    \"\"\"Generate time series data for the harmonic oscillator.\n\n    Returns a list of floats representing the displacement at each time step.\n\n    :param n_periods: Number of periods to generate.\n    :param n_samples_per_period: Number of samples per period.\n    \"\"\"\n    time_delta = self.system.period / n_samples_per_period\n    time_steps = np.arange(0, n_periods * n_samples_per_period) * time_delta\n\n    data = self._x(time_steps)\n\n    return pd.DataFrame({\"t\": time_steps, \"x\": data})\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorBase._x","title":"<code>_x(t)</code>  <code>abstractmethod</code>","text":"<p>Solution to simple harmonic oscillators.</p> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>@abstractmethod\ndef _x(self, t: ArrayLike) -&gt; ArrayLike:\n    r\"\"\"Solution to simple harmonic oscillators.\"\"\"\n    ...\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorIC","title":"<code>HarmonicOscillatorIC</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The initial condition for a harmonic oscillator</p> <p>Attributes:</p> Name Type Description <code>x0</code> <code>float</code> <p>the initial displacement</p> <code>v0</code> <code>float</code> <p>the initial velocity</p> <code>phi</code> <code>float</code> <p>initial phase</p> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class HarmonicOscillatorIC(BaseModel):\n    \"\"\"The initial condition for a harmonic oscillator\n\n    :cvar x0: the initial displacement\n    :cvar v0: the initial velocity\n    :cvar phi: initial phase\n    \"\"\"\n\n    x0: float = 1.0\n    v0: float = 0.0\n    phi: float = 0.0\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem","title":"<code>HarmonicOscillatorSystem</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The params for the harmonic oscillator</p> <p>Attributes:</p> Name Type Description <code>omega</code> <code>float</code> <p>angular frequency of the harmonic oscillator</p> <code>zeta</code> <code>float</code> <p>damping ratio</p> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class HarmonicOscillatorSystem(BaseModel):\n    \"\"\"The params for the harmonic oscillator\n\n    :cvar omega: angular frequency of the harmonic oscillator\n    :cvar zeta: damping ratio\n    \"\"\"\n\n    omega: float\n    zeta: float = 0.0\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def period(self) -&gt; float:\n        \"\"\"period of the oscillator\"\"\"\n        return 2 * np.pi / self.omega\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def frequency(self) -&gt; float:\n        \"\"\"frequency of the oscillator\"\"\"\n        return 1 / self.period\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def type(\n        self,\n    ) -&gt; Literal[\"simple\", \"under_damped\", \"critical_damped\", \"over_damped\"]:\n        \"\"\"which type of harmonic oscillators\"\"\"\n        if self.zeta == 0:\n            return \"simple\"\n        elif self.zeta &lt; 1:\n            return \"under_damped\"\n        elif self.zeta == 1:\n            return \"critical_damped\"\n        else:\n            return \"over_damped\"\n\n    @field_validator(\"zeta\")\n    @classmethod\n    def check_zeta_non_negative(cls, v: float) -&gt; float:\n        if v &lt; 0:\n            raise ValueError(f\"Value of zeta should be positive: {v=}\")\n\n        return v\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem.frequency","title":"<code>frequency: float</code>  <code>cached</code> <code>property</code>","text":"<p>frequency of the oscillator</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem.period","title":"<code>period: float</code>  <code>cached</code> <code>property</code>","text":"<p>period of the oscillator</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem.type","title":"<code>type: Literal['simple', 'under_damped', 'critical_damped', 'over_damped']</code>  <code>cached</code> <code>property</code>","text":"<p>which type of harmonic oscillators</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.SimpleHarmonicOscillator","title":"<code>SimpleHarmonicOscillator</code>","text":"<p>             Bases: <code>HarmonicOscillatorBase</code></p> <p>Generate time series data for a simple harmonic oscillator.</p> <p>In a one dimensional world, a mass \\(m\\), driven by a force \\(F=-kx\\), is described as</p> \\[ \\begin{align} F &amp;= - k x \\\\ F &amp;= m a \\end{align} \\] <p>The mass behaves like a simple harmonic oscillator.</p> <p>In general, the solution to a simple harmonic oscillator is</p> \\[ x(t) = A \\cos(\\omega t + \\phi), \\] <p>where \\(\\omega\\) is the angular frequency, \\(\\phi\\) is the initial phase, and \\(A\\) is the amplitude.</p> <p>To use this generator,</p> <pre><code>params = {\"omega\": omega}\n\nho = SimpleHarmonicOscillator(params=params)\n\ndf = ho(n_periods=1, n_samples_per_period=10)\n</code></pre> <p><code>df</code> will be a pandas dataframe with two columns: <code>t</code> and <code>x</code>.</p> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class SimpleHarmonicOscillator(HarmonicOscillatorBase):\n    r\"\"\"Generate time series data for a\n    [simple harmonic oscillator](https://en.wikipedia.org/wiki/Harmonic_oscillator).\n\n\n    In a one dimensional world, a mass $m$, driven by a force $F=-kx$, is described as\n\n    $$\n    \\begin{align}\n    F &amp;= - k x \\\\\n    F &amp;= m a\n    \\end{align}\n    $$\n\n    The mass behaves like a simple harmonic oscillator.\n\n    In general, the solution to a simple harmonic oscillator is\n\n    $$\n    x(t) = A \\cos(\\omega t + \\phi),\n    $$\n\n    where $\\omega$ is the angular frequency, $\\phi$ is the initial phase, and $A$ is the amplitude.\n\n\n    To use this generator,\n\n    ```python\n    params = {\"omega\": omega}\n\n    ho = SimpleHarmonicOscillator(params=params)\n\n    df = ho(n_periods=1, n_samples_per_period=10)\n    ```\n\n    `df` will be a pandas dataframe with two columns: `t` and `x`.\n    \"\"\"\n\n    def __init__(\n        self,\n        system: Dict[str, float],\n        initial_condition: Optional[Dict[str, float]] = {},\n    ):\n        super().__init__(system, initial_condition)\n        if self.system.type != \"simple\":\n            raise ValueError(\n                f\"System is not a Simple Harmonic Oscillator: {self.system}\"\n            )\n\n    def _x(self, t: ArrayLike) -&gt; ArrayLike:\n        r\"\"\"Solution to simple harmonic oscillators:\n\n        $$\n        x(t) = x_0 \\cos(\\omega t + \\phi).\n        $$\n        \"\"\"\n        return self.initial_condition.x0 * np.cos(\n            self.system.omega * t + self.initial_condition.phi\n        )\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.SimpleHarmonicOscillator._x","title":"<code>_x(t)</code>","text":"<p>Solution to simple harmonic oscillators:</p> \\[ x(t) = x_0 \\cos(\\omega t + \\phi). \\] Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def _x(self, t: ArrayLike) -&gt; ArrayLike:\n    r\"\"\"Solution to simple harmonic oscillators:\n\n    $$\n    x(t) = x_0 \\cos(\\omega t + \\phi).\n    $$\n    \"\"\"\n    return self.initial_condition.x0 * np.cos(\n        self.system.omega * t + self.initial_condition.phi\n    )\n</code></pre>"},{"location":"references/models/pendulum/","title":"Pendulum","text":""},{"location":"references/models/pendulum/#hamilflow.models.pendulum.Pendulum","title":"<code>Pendulum</code>","text":"<p>Generate time series data for a pendulum.</p> <p>We describe a generic pendulum system by the Lagrangian action $$ S_L[\\theta] = I \\int_{t_0}^{t_1} \\mathbb{d}t \\left\\{\\frac{1}{2} \\dot\\theta^2 + \\omega_0^2 \\cos\\theta \\right\\}\\,, $$ where \\(\\theta\\) is the angle from the vertical to the pendulum; \\(I\\) is the inertia parameter introduced for dimensional reasons, and \\(\\omega_0\\) the frequency parameter.</p> <p>Details are collected in the tutorial.</p> Source code in <code>hamilflow/models/pendulum.py</code> <pre><code>class Pendulum:\n    r\"\"\"Generate time series data for a pendulum.\n\n    We describe a generic pendulum system by the Lagrangian action\n    $$\n    S_L\\[\\theta\\] = I \\int_{t_0}^{t_1} \\mathbb{d}t\n    \\left\\\\{\\frac{1}{2} \\dot\\theta^2 + \\omega_0^2 \\cos\\theta \\right\\\\}\\,,\n    $$\n    where $\\theta$ is the _angle_ from the vertical to the pendulum;\n    $I$ is the _inertia parameter_ introduced for dimensional reasons,\n    and $\\omega_0$ the _frequency parameter_.\n\n    Details are collected in the tutorial.\n    \"\"\"\n\n    def __init__(\n        self,\n        system: Union[int, float, Dict[str, Union[int, float]]],\n        initial_condition: Union[int, float, Dict[str, Union[int, float]]],\n    ) -&gt; None:\n        if isinstance(system, (float, int)):\n            system = {\"omega0\": system}\n        if isinstance(initial_condition, (float, int)):\n            initial_condition = {\"theta0\": initial_condition}\n        self.system = PendulumSystem.model_validate(system)\n        self.initial_condition = PendulumIC.model_validate(initial_condition)\n\n    @cached_property\n    def definition(self) -&gt; Dict[str, float]:\n        \"\"\"Model params and initial conditions defined as a dictionary.\"\"\"\n        return dict(\n            system=self.system.model_dump(),\n            initial_condition=self.initial_condition.model_dump(),\n        )\n\n    @property\n    def omega0(self) -&gt; float:\n        return self.system.omega0\n\n    @property\n    def _k(self) -&gt; float:\n        return self.initial_condition.k\n\n    @property\n    def _math_m(self) -&gt; float:\n        return self._k**2\n\n    @cached_property\n    def freq(self) -&gt; float:\n        r\"\"\"Frequency.\n\n        :return: $\\frac{\\pi}{2K(k^2)}\\omega_0$, where\n        $K(m)$ is [Legendre's complete elliptic integral of the first kind](https://dlmf.nist.gov/19.2#E8)\n        \"\"\"\n        return math.pi * self.omega0 / (2 * ellipk(self._math_m))\n\n    @cached_property\n    def period(self) -&gt; float:\n        r\"\"\"Period.\n\n        :return: $\\frac{4K(k^2)}{\\omega_0}$, where\n        $K(m)$ is [Legendre's complete elliptic integral of the first kind](https://dlmf.nist.gov/19.2#E8)\n        \"\"\"\n        return 4 * ellipk(self._math_m) / self.omega0\n\n    def _math_u(self, t: ArrayLike) -&gt; np.ndarray[float]:\n        return self.omega0 * np.asarray(t)\n\n    def u(self, t: ArrayLike) -&gt; np.ndarray[float]:\n        r\"\"\"The convenient generalised coordinate $u$,\n        $\\sin u \\coloneqq \\frac{\\sin\\frac{\\theta}{2}}{\\sin\\frac{\\theta_0}{2}}$.\n\n        :param t: time\n        :return: $u(t) = \\mathrm{am}\\!\\big(\\omega_0 t + K(k^2), k^2\\big)$, where\n        $\\mathrm{am}(x, k)$ is [Jacobi's amplitude function](https://dlmf.nist.gov/22.16#E1),\n        $K(m)$ is [Legendre's complete elliptic integral of the first kind](https://dlmf.nist.gov/19.2#E8)\n        \"\"\"\n        _, _, _, ph = ellipj(self._math_u(t) + ellipk(self._math_m), self._math_m)\n\n        return ph\n\n    def theta(self, t: ArrayLike) -&gt; np.ndarray[float]:\n        r\"\"\"Angle $\\theta$.\n\n        :param t: time\n        :return: $\\theta(t) = 2\\arcsin\\!\\big(k\\cdot\\mathrm{cd}(\\omega_0 t, k^2)\\big)$, where\n        $\\mathrm{cd}(z, k)$ is a [Jacobian elliptic function](https://dlmf.nist.gov/22.2#E8)\n        \"\"\"\n        _, cn, dn, _ = ellipj(self._math_u(t), self._math_m)\n\n        return 2 * np.arcsin(cn / dn * self._k)\n\n    def __call__(self, n_periods: int, n_samples_per_period: int) -&gt; pd.DataFrame:\n        time_delta = self.period / n_samples_per_period\n        time_steps = np.arange(0, n_periods * n_samples_per_period) * time_delta\n\n        thetas = self.theta(time_steps)\n        us = self.u(time_steps)\n\n        return pd.DataFrame(dict(t=time_steps, x=thetas, u=us))\n</code></pre>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.Pendulum.definition","title":"<code>definition: Dict[str, float]</code>  <code>cached</code> <code>property</code>","text":"<p>Model params and initial conditions defined as a dictionary.</p>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.Pendulum.freq","title":"<code>freq: float</code>  <code>cached</code> <code>property</code>","text":"<p>Frequency.</p> <p>Returns:</p> Type Description <code>float</code> <p>\\(\\frac{\\pi}{2K(k^2)}\\omega_0\\), where \\(K(m)\\) is Legendre's complete elliptic integral of the first kind</p>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.Pendulum.period","title":"<code>period: float</code>  <code>cached</code> <code>property</code>","text":"<p>Period.</p> <p>Returns:</p> Type Description <code>float</code> <p>\\(\\frac{4K(k^2)}{\\omega_0}\\), where \\(K(m)\\) is Legendre's complete elliptic integral of the first kind</p>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.Pendulum.theta","title":"<code>theta(t)</code>","text":"<p>Angle \\(\\theta\\).</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ArrayLike</code> <p>time</p> required <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>\\(\\theta(t) = 2\\arcsin\\!\\big(k\\cdot\\mathrm{cd}(\\omega_0 t, k^2)\\big)\\), where \\(\\mathrm{cd}(z, k)\\) is a Jacobian elliptic function</p> Source code in <code>hamilflow/models/pendulum.py</code> <pre><code>def theta(self, t: ArrayLike) -&gt; np.ndarray[float]:\n    r\"\"\"Angle $\\theta$.\n\n    :param t: time\n    :return: $\\theta(t) = 2\\arcsin\\!\\big(k\\cdot\\mathrm{cd}(\\omega_0 t, k^2)\\big)$, where\n    $\\mathrm{cd}(z, k)$ is a [Jacobian elliptic function](https://dlmf.nist.gov/22.2#E8)\n    \"\"\"\n    _, cn, dn, _ = ellipj(self._math_u(t), self._math_m)\n\n    return 2 * np.arcsin(cn / dn * self._k)\n</code></pre>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.Pendulum.u","title":"<code>u(t)</code>","text":"<p>The convenient generalised coordinate \\(u\\), \\(\\sin u \\coloneqq \\frac{\\sin\\frac{\\theta}{2}}{\\sin\\frac{\\theta_0}{2}}\\).</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ArrayLike</code> <p>time</p> required <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>\\(u(t) = \\mathrm{am}\\!\\big(\\omega_0 t + K(k^2), k^2\\big)\\), where \\(\\mathrm{am}(x, k)\\) is Jacobi's amplitude function, \\(K(m)\\) is Legendre's complete elliptic integral of the first kind</p> Source code in <code>hamilflow/models/pendulum.py</code> <pre><code>def u(self, t: ArrayLike) -&gt; np.ndarray[float]:\n    r\"\"\"The convenient generalised coordinate $u$,\n    $\\sin u \\coloneqq \\frac{\\sin\\frac{\\theta}{2}}{\\sin\\frac{\\theta_0}{2}}$.\n\n    :param t: time\n    :return: $u(t) = \\mathrm{am}\\!\\big(\\omega_0 t + K(k^2), k^2\\big)$, where\n    $\\mathrm{am}(x, k)$ is [Jacobi's amplitude function](https://dlmf.nist.gov/22.16#E1),\n    $K(m)$ is [Legendre's complete elliptic integral of the first kind](https://dlmf.nist.gov/19.2#E8)\n    \"\"\"\n    _, _, _, ph = ellipj(self._math_u(t) + ellipk(self._math_m), self._math_m)\n\n    return ph\n</code></pre>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.PendulumIC","title":"<code>PendulumIC</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The initial condition for a pendulum.</p> <p>Parameters:</p> Name Type Description Default <code>theta0</code> <p>\\(-\\frac{\\pi}{2} \\le \\theta_0 \\le \\frac{\\pi}{2}\\), the initial angle</p> required Source code in <code>hamilflow/models/pendulum.py</code> <pre><code>class PendulumIC(BaseModel):\n    r\"\"\"The initial condition for a pendulum.\n\n    :param theta0: $-\\frac{\\pi}{2} \\le \\theta_0 \\le \\frac{\\pi}{2}$, the\n    initial angle\n    \"\"\"\n\n    theta0: float = Field(ge=-math.pi / 2, le=math.pi / 2, frozen=True)\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def k(self) -&gt; float:\n        r\"\"\"A convenient number for elliptic functions.\n\n        :return: $\\sin\\frac{\\theta_0}{2}$\n        \"\"\"\n        return math.sin(self.theta0 / 2)\n</code></pre>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.PendulumIC.k","title":"<code>k: float</code>  <code>cached</code> <code>property</code>","text":"<p>A convenient number for elliptic functions.</p> <p>Returns:</p> Type Description <code>float</code> <p>\\(\\sin\\frac{\\theta_0}{2}\\)</p>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.PendulumSystem","title":"<code>PendulumSystem</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The params for the pendulum.</p> <p>Parameters:</p> Name Type Description Default <code>omega0</code> <p>\\(\\omega_0 \\coloneqq \\sqrt{\\frac{U}{I}} &gt; 0\\), frequency parameter</p> required Source code in <code>hamilflow/models/pendulum.py</code> <pre><code>class PendulumSystem(BaseModel):\n    r\"\"\"The params for the pendulum.\n\n    :param omega0: $\\omega_0 \\coloneqq \\sqrt{\\frac{U}{I}} &gt; 0$, frequency\n    parameter\n    \"\"\"\n\n    omega0: float = Field(gt=0, frozen=True)\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>We provide some tutorials to help you get started.</p> <p>For easier reading, we following the following notations whenever possible.</p> Notation Description \\(\\mathcal L\\) Lagrangian \\(L\\) Angular Momentum \\(V\\) Potential"},{"location":"tutorials/brownian_motion/","title":"Brownian Motion","text":"In\u00a0[1]: Copied! <pre>import plotly.express as px\n\nfrom hamilflow.models.brownian_motion import BrownianMotion\n</pre> import plotly.express as px  from hamilflow.models.brownian_motion import BrownianMotion In\u00a0[2]: Copied! <pre>bm_1d = BrownianMotion(\n    system={\n        \"sigma\": 1,\n        \"delta_t\": 1,\n    },\n    initial_condition={\"x0\": 0},\n)\n</pre> bm_1d = BrownianMotion(     system={         \"sigma\": 1,         \"delta_t\": 1,     },     initial_condition={\"x0\": 0}, ) <p>Call the model to generate 1000 steps.</p> In\u00a0[3]: Copied! <pre>df_1d = bm_1d(n_steps=1000)\n</pre> df_1d = bm_1d(n_steps=1000) In\u00a0[4]: Copied! <pre>px.line(df_1d, x=\"t\", y=\"y_0\")\n</pre> px.line(df_1d, x=\"t\", y=\"y_0\") In\u00a0[5]: Copied! <pre>bm_2d = BrownianMotion(\n    system={\n        \"sigma\": 1,\n        \"delta_t\": 1,\n    },\n    initial_condition={\"x0\": [0, 0]},\n)\n</pre> bm_2d = BrownianMotion(     system={         \"sigma\": 1,         \"delta_t\": 1,     },     initial_condition={\"x0\": [0, 0]}, ) <p>We call the model to generate 1000 steps.</p> In\u00a0[6]: Copied! <pre>df_2d = bm_2d(n_steps=500)\n</pre> df_2d = bm_2d(n_steps=500) In\u00a0[7]: Copied! <pre>(\n    px.scatter(df_2d, x=\"y_0\", y=\"y_1\", color=\"t\")\n    .update_traces(\n        mode=\"lines+markers\",\n        marker=dict(\n            size=2.5,\n        ),\n        line=dict(width=1),\n    )\n    .update_yaxes(\n        scaleanchor=\"x\",\n        scaleratio=1,\n    )\n)\n</pre> (     px.scatter(df_2d, x=\"y_0\", y=\"y_1\", color=\"t\")     .update_traces(         mode=\"lines+markers\",         marker=dict(             size=2.5,         ),         line=dict(width=1),     )     .update_yaxes(         scaleanchor=\"x\",         scaleratio=1,     ) ) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/brownian_motion/#brownian-motion","title":"Brownian Motion\u00b6","text":"<p>Brownian motion describes motion of small particles with stochastic forces applied to them. The math of Brownian motion can be modeled with Wiener process. In this tutorial, we take a simple form of the model and treat the stochastic forces as Gaussian.</p> <p>For consistency, we always use $\\mathbf x$ for displacement, and $t$ for steps. The model we are using is</p> <p>$$ \\begin{align} \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) + \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t}) \\end{align} $$</p> <p>Read more:</p> <ol> <li>Brownian motion and random walks. [cited 13 Mar 2024]. Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html</li> <li>Contributors to Wikimedia projects. Brownian motion. In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024]. Available: https://en.wikipedia.org/wiki/Brownian_motion</li> </ol> <p><code>hamilflow</code> implemented a Brownian motion model called <code>BrownianMotion</code>.</p>"},{"location":"tutorials/brownian_motion/#1d-brownian-motion","title":"1D Brownian Motion\u00b6","text":""},{"location":"tutorials/brownian_motion/#2d-brownian-motion","title":"2D Brownian Motion\u00b6","text":"<p>Our <code>BrownianMotion</code> model calculates the dimension of the space based on the dimension of the initial condition $x_0$. To create a 2D Brownian motion model, we need the initial condition to be length 2.</p>"},{"location":"tutorials/central_force_motion/","title":"Motion in a Central Field","text":"<p>In this section, we briefly discuss the derivations of motion in a central field. Please refer to Mechanics: Vol 1 by Landau and Lifshitz for more details[^1].</p> <p>The Lagrangian for an object in a central field is</p> <p>$$ \\mathcal  L = \\frac{1}{2} m ({\\dot r}^2 + r^2 {\\dot \\phi}^2) - V(r), $$</p> <p>where $r$ and $\\phi$ are the polar coordinates, $m$ is the mass of the object, and $V(r)$ is the potential energy. The equations of motion are</p> <p>$$ \\begin{align} \\frac{\\mathrm d r}{\\mathrm d t}  &amp;= \\sqrt{ \\frac{2}{m} (E - V(r)) - \\frac{L^2}{m^2 r^2} } \\\\ \\frac{\\mathrm d \\phi}{\\mathrm d t} &amp;= \\frac{L}{m r^2}, \\end{align} $$</p> <p>where $E$ is the total energy and $L$ is the angular momentum. Both $E$ and $L$ are conserved. We obtain the coordinates as a function of time by solving the two equations.</p> <p>For a inverse-square force, the potential energy is</p> <p>$$ V(r) = - \\frac{\\alpha}{r}, $$</p> <p>where $\\alpha$ is a constant that specifies the strength of the force. For Newtonian gravity, $\\alpha = G m_0$ with $G$ being the gravitational constant.</p> <p>First of all, we solve $\\phi(r)$,</p> <p>$$ \\phi = \\cos^{-1}\\left( \\frac{L/r - m\\alpha/L}{2 m E + m \\alpha^2/L^2} \\right). $$</p> <p>Define</p> <p>$$ p = \\frac{L^2}{m\\alpha} $$</p> <p>and</p> <p>$$ e = \\sqrt{ 1 + \\frac{2 E L^2}{m \\alpha^2}}, $$</p> <p>we rewrite the solution $\\phi(r)$ as</p> <p>$$ r = \\frac{p}{1 + e \\cos{\\phi}}. $$</p> <p>With the above relationship between $r$ and $\\phi$, and $\\frac{\\mathrm d \\phi}{\\mathrm d} = \\frac{L}{mr^2}$, we find that</p> <p>$$ \\frac{m\\alpha^2}{L^3} \\mathrm d t = \\frac{1}{(1 + e \\cos{\\phi})^2} \\mathrm d \\phi. $$</p> <p>The integration on the right hand side depends on the domain of $e$.</p> <p>$$ \\int\\frac{1}{(1 + e \\cos{\\phi})^2} \\mathrm d \\phi = \\begin{cases} \\frac{1}{(1 - e^2)^{3/2}} \\left( 2 \\tan^{-1} \\sqrt{\\frac{1 - e}{1 + e}} \\tan\\frac{\\phi}{2} - \\frac{e\\sqrt{1 - e^2}\\sin\\phi}{1 + e\\cos\\phi} \\right), &amp; \\text{if } e&lt;1 \\\\ \\frac{1}{2}\\tan{\\frac{\\phi}{2}} + \\frac{1}{6}\\tan^3{\\frac{\\phi}{2}}, &amp; \\text{if } e=1 \\\\ \\frac{1}{(e^2 - 1)^{3/2}}\\left( \\frac{e\\sqrt{e^2-1}\\sin\\phi}{1 + e\\cos\\phi} - \\ln \\left( \\frac{\\sqrt{1 + e} + \\sqrt{e-1}\\tan\\frac{\\phi}{2}}{\\sqrt{1 + e} - \\sqrt{e-1}\\tan\\frac{\\phi}{2} } \\right) \\right), &amp; \\text{if } e&gt; 1. \\end{cases} $$</p> <p>The value of $t(\\phi)$ is easily obtained from the above formulae.</p> <p>There exists many numerical methods to solve the Kepler orbits as functions of time, $r(t)$ and $\\phi(t)$. For our use case of the solutions, we choose to integrate the equation of motion directly.</p> <p>References:</p> <ol> <li>Landau LD, Lifshitz EM. Mechanics: Vol 1. 3rd ed. Oxford, England: Butterworth-Heinemann; 1982.</li> <li>Klioner SA. Basic Celestial Mechanics. arXiv [astro-ph.IM]. 2016. Available: http://arxiv.org/abs/1609.00915</li> </ol>"},{"location":"tutorials/central_force_motion/#motion-in-a-central-field","title":"Motion in a Central Field\u00b6","text":"<p>In this tutorial, we generate data for objects moving in a central field.</p>"},{"location":"tutorials/central_force_motion/#formalism","title":"Formalism\u00b6","text":""},{"location":"tutorials/harmonic_oscillator/","title":"Harmonic Oscillators","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport plotly.express as px\n\nfrom hamilflow.models.harmonic_oscillator import (\n    DampedHarmonicOscillator,\n    SimpleHarmonicOscillator,\n)\n</pre> import pandas as pd import plotly.express as px  from hamilflow.models.harmonic_oscillator import (     DampedHarmonicOscillator,     SimpleHarmonicOscillator, ) <pre>/tmp/ipykernel_1979/2648449548.py:1: DeprecationWarning: \nPyarrow will become a required dependency of pandas in the next major release of pandas (pandas 3.0),\n(to allow more performant data types, such as the Arrow string type, and better interoperability with other libraries)\nbut was not found to be installed on your system.\nIf this would cause problems for you,\nplease provide us feedback at https://github.com/pandas-dev/pandas/issues/54466\n        \n  import pandas as pd\n</pre> In\u00a0[2]: Copied! <pre>n_periods = 3\nn_samples_per_period = 200\n</pre> n_periods = 3 n_samples_per_period = 200 In\u00a0[3]: Copied! <pre>sho_omega = 0.5\n\nsho = SimpleHarmonicOscillator(system={\"omega\": sho_omega})\n</pre> sho_omega = 0.5  sho = SimpleHarmonicOscillator(system={\"omega\": sho_omega}) In\u00a0[4]: Copied! <pre>df_sho = sho(n_periods=n_periods, n_samples_per_period=n_samples_per_period)\ndf_sho.head()\n</pre> df_sho = sho(n_periods=n_periods, n_samples_per_period=n_samples_per_period) df_sho.head() Out[4]: t x 0 0.000000 1.000000 1 0.062832 0.999507 2 0.125664 0.998027 3 0.188496 0.995562 4 0.251327 0.992115 In\u00a0[5]: Copied! <pre>px.line(\n    df_sho,\n    x=\"t\",\n    y=\"x\",\n    title=rf\"Simple Harmonic Oscillator (omega = {sho_omega})\",\n    labels={\n        \"x\": r\"Displacement $x(t)$\",\n        \"t\": r\"$t$\",\n    },\n)\n</pre> px.line(     df_sho,     x=\"t\",     y=\"x\",     title=rf\"Simple Harmonic Oscillator (omega = {sho_omega})\",     labels={         \"x\": r\"Displacement $x(t)$\",         \"t\": r\"$t$\",     }, ) In\u00a0[6]: Copied! <pre>dho_systems = {\n    \"Underdamped\": {\"omega\": 0.5, \"zeta\": 0.2},\n    \"Critical Damped\": {\"omega\": 0.5, \"zeta\": 1},\n    \"Overdamped\": {\n        \"omega\": 0.5,\n        \"zeta\": 1.2,\n    },\n}\n\ndfs_dho = []\n\nfor s_name, s in dho_systems.items():\n\n    dfs_dho.append(\n        DampedHarmonicOscillator(system=s)(\n            n_periods=n_periods, n_samples_per_period=n_samples_per_period\n        ).assign(system=rf\"{s_name} (omega = {s.get('omega')}, zeta = {s.get('zeta')})\")\n    )\n\nfig = px.line(\n    pd.concat(dfs_dho),\n    x=\"t\",\n    y=\"x\",\n    color=\"system\",\n    title=rf\"Damped Harmonic Oscillator\",\n    labels={\n        \"x\": r\"Displacement $x(t)$\",\n        \"t\": r\"$t$\",\n    },\n)\nfig.update_layout(legend={\"yanchor\": \"top\", \"y\": -0.2, \"xanchor\": \"left\", \"x\": 0})\n</pre> dho_systems = {     \"Underdamped\": {\"omega\": 0.5, \"zeta\": 0.2},     \"Critical Damped\": {\"omega\": 0.5, \"zeta\": 1},     \"Overdamped\": {         \"omega\": 0.5,         \"zeta\": 1.2,     }, }  dfs_dho = []  for s_name, s in dho_systems.items():      dfs_dho.append(         DampedHarmonicOscillator(system=s)(             n_periods=n_periods, n_samples_per_period=n_samples_per_period         ).assign(system=rf\"{s_name} (omega = {s.get('omega')}, zeta = {s.get('zeta')})\")     )  fig = px.line(     pd.concat(dfs_dho),     x=\"t\",     y=\"x\",     color=\"system\",     title=rf\"Damped Harmonic Oscillator\",     labels={         \"x\": r\"Displacement $x(t)$\",         \"t\": r\"$t$\",     }, ) fig.update_layout(legend={\"yanchor\": \"top\", \"y\": -0.2, \"xanchor\": \"left\", \"x\": 0}) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/harmonic_oscillator/#harmonic-oscillators","title":"Harmonic Oscillators\u00b6","text":"<p>In this tutorial, we demo how to generate data of harmonic oscillators.</p>"},{"location":"tutorials/harmonic_oscillator/#simple-harmonic-oscillator","title":"Simple Harmonic Oscillator\u00b6","text":"<p>For an simple harmonic oscillator, the action of a simple harmonic oscillator is</p> <p>$$S_L[x] = \\int_{t_0}^{t_1} \\mathbb{d}t \\left\\{\\frac{1}{2} m \\dot x^2 - \\frac{1}{2} m \\omega^2 x^2 \\right\\}\\,,$$</p> <p>where the least action principle leads to the following equation of motion,</p> <p>$$ \\ddot x + \\omega^2 x = 0\\,. $$</p> <p>A simple harmonic oscillator is a periodic motion.</p>"},{"location":"tutorials/harmonic_oscillator/#damped-harmonic-oscillator","title":"Damped Harmonic Oscillator\u00b6","text":"<p>A damped harmonic oscillator is a simple harmonic oscillator with damping force that is proportional to its velocity,</p> <p>$$ \\ddot x + \\omega^2 x = - 2\\xi\\omega \\dot x\\,. $$</p> <p>In this section, we demonstrate three scenarios of a damped harmonic oscillator.</p>"},{"location":"tutorials/pendulum/","title":"Pendulum","text":"In\u00a0[1]: Copied! <pre>import math\n\nimport plotly.express as px\n\nfrom hamilflow.models.pendulum import Pendulum\n</pre> import math  import plotly.express as px  from hamilflow.models.pendulum import Pendulum In\u00a0[2]: Copied! <pre>omega0 = 2 * math.pi\ntheta0 = math.pi / 3\n\nn_periods = 2**2\nn_samples_per_period = 2**8\n</pre> omega0 = 2 * math.pi theta0 = math.pi / 3  n_periods = 2**2 n_samples_per_period = 2**8 In\u00a0[3]: Copied! <pre>pen = Pendulum(system=omega0, initial_condition=theta0)\n</pre> pen = Pendulum(system=omega0, initial_condition=theta0) In\u00a0[4]: Copied! <pre>df_pen = pen(n_periods=n_periods, n_samples_per_period=n_samples_per_period)\ndf_pen.head()\n</pre> df_pen = pen(n_periods=n_periods, n_samples_per_period=n_samples_per_period) df_pen.head() Out[4]: t x u 0 0.000000 1.047198 1.570796 1 0.004192 1.046897 1.593608 2 0.008384 1.045996 1.616424 3 0.012576 1.044494 1.639247 4 0.016768 1.042393 1.662082 In\u00a0[5]: Copied! <pre>df_pen.describe()\n</pre> df_pen.describe() Out[5]: t x u count 1024.000000 1.024000e+03 1024.000000 mean 2.144268 2.320193e-17 14.124895 std 1.239809 7.453532e-01 7.261249 min 0.000000 -1.047198e+00 1.570796 25% 1.072134 -7.494689e-01 7.848279 50% 2.144268 -3.535251e-16 14.125761 75% 3.216402 7.494689e-01 20.403244 max 4.288536 1.047198e+00 26.680726 In\u00a0[6]: Copied! <pre>px.line(\n    df_pen,\n    x=\"t\",\n    y=\"x\",\n    title=r\"Simple Harmonic Oscillator ($\\omega_0 = {:.4f})$\".format(omega0),\n    labels=dict(x=r\"Angle $\\theta(t)$\", t=r\"Time $t$\"),\n)\n</pre> px.line(     df_pen,     x=\"t\",     y=\"x\",     title=r\"Simple Harmonic Oscillator ($\\omega_0 = {:.4f})$\".format(omega0),     labels=dict(x=r\"Angle $\\theta(t)$\", t=r\"Time $t$\"), )"},{"location":"tutorials/pendulum/#pendulum","title":"Pendulum\u00b6","text":"<p>In this tutorial, we demonstrate how to generate data of a pendulum, and introduce the mathematics of a pendulum.</p>"},{"location":"tutorials/pendulum/#constants","title":"Constants\u00b6","text":""},{"location":"tutorials/pendulum/#a-pendulum","title":"A pendulum\u00b6","text":""},{"location":"tutorials/pendulum/#data","title":"Data\u00b6","text":""},{"location":"tutorials/pendulum/#plot","title":"Plot\u00b6","text":""},{"location":"tutorials/pendulum/#todo","title":"TODO\u00b6","text":"<ul> <li>Compare with a harmonic oscillator in terms of frequency and profile</li> <li>Animate the plot as a single pendulum</li> <li>Add references to the derivation</li> <li>Complete the derivation</li> </ul>"},{"location":"tutorials/pendulum/#mathematical-physical-description","title":"Mathematical-physical description\u00b6","text":""},{"location":"tutorials/pendulum/#lagrangian-action","title":"Lagrangian action\u00b6","text":"<p>We describe a generic pendulum system by the Lagrangian action $$ S_L[\\theta] \\equiv \\int_{t_0}^{t_1} \\mathbb{d}t\\,L(\\theta, \\dot\\theta) \\eqqcolon I \\int_{t_0}^{t_1} \\mathbb{d}t \\left\\{\\frac{1}{2} \\dot\\theta^2 + \\omega_0^2 \\cos\\theta \\right\\}\\,, $$ where $L$ is the Lagrangian; $\\theta$ is the angle from the vertical to the pendulum as the generalised position; $I$ is the inertia parameter, $\\omega_0$ the frequency parameter, and we also call $U \\coloneqq I\\omega_0^2$ the potential parameter.</p> <p>This setup contains both the single and the physical pendula. For a single pendulum, $$ I = m l^2\\,,\\qquad U = mgl\\,, $$ where $m$ is the mass of the pendulum, $l$ is the length of the rod or cord, and $g$ is the gravitational acceleration.</p>"},{"location":"tutorials/pendulum/#integral-of-motion","title":"Integral of motion\u00b6","text":"<p>The Lagrangian action does not contain time $t$ explicitly. As a result, the system is invariant under a variation of time, or $\\mathbb{\\delta}S / \\mathbb{\\delta}{t} = 0$. This gives an integral of motion $$ \\dot\\theta\\frac{\\partial L}{\\partial \\dot\\theta} - L \\equiv E \\eqqcolon I \\omega_0^2 \\cos\\theta_0\\,, $$ where $\\theta_0$ is the initial angle.</p> <p>Substitution gives $$ \\left(\\frac{\\mathbb{d}t}{\\mathbb{d}\\theta}\\right)^2 = \\frac{1}{2\\omega_0^2} \\frac{1}{\\cos\\theta - \\cos\\theta_0}\\,. $$</p>"},{"location":"tutorials/pendulum/#coordinate-transformation","title":"Coordinate transformation\u00b6","text":"<p>For convenience, introduce the coordinate $u$ and the parameter $k$ $$ \\sin u \\coloneqq \\frac{\\sin\\frac{\\theta}{2}}{k}\\,,\\qquad k \\coloneqq \\sin\\frac{\\theta_0}{2} \\in [-1, 1]\\,. $$ One arrives at $$ \\left(\\frac{\\mathbb{d}t}{\\mathbb{d}u}\\right)^2 = \\frac{1}{\\omega_0^2} \\frac{1}{1-k^2\\sin^2 u}\\,. $$ The square root of the second factor on the right-hand side makes an elliptic integral.</p>"},{"location":"tutorials/pendulum/#end-of-notebook","title":"End of Notebook\u00b6","text":""}]}