{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation for <code>hamilflow</code>","text":"<p>Generating dataset for physical systems.</p>"},{"location":"#development","title":"Development","text":"<p>We use <code>poetry</code> to manage our python environment. Use</p> <pre><code>poetry install\n</code></pre> <p>to install the requirements. Or run</p> <pre><code>poetry install --with test\n</code></pre> <p>to install the base environment and test environment for development.</p> <p>If this is the first you clone the repo and committing code, run</p> <pre><code>pre-commit install\n</code></pre> <p>first.</p>"},{"location":"changelog/","title":"hamilflow Changelog","text":""},{"location":"changelog/#010-2024-03-21","title":"0.1.0 (2024-03-21)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>model: add brownian motion (#23)</li> <li>ops: #18 use commitizen (#21)</li> </ul>"},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>docs: fix docstrings for pydantic models cvar (#27)</li> </ul>"},{"location":"changelog/#2024-02-18-001","title":"2024-02-18, 0.0.1","text":"<p>Setting up repository.</p>"},{"location":"references/","title":"References","text":""},{"location":"references/models/brownian_motion/","title":"Brownian Motion","text":""},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotion","title":"<code>BrownianMotion</code>","text":"<p>Brownian motion describes motion of small particles with stochastic forces applied to them. The math of Brownian motion can be modeled with Wiener process.</p> <p>For consistency, we always use \\(\\mathbf x\\) for displacement, and \\(t\\) for steps. The model we are using is</p> \\[ \\begin{align} \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) + \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t}) \\end{align} \\] <p>References:</p> <ol> <li>Brownian motion and random walks. [cited 13 Mar 2024].     Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html</li> <li>Contributors to Wikimedia projects. Brownian motion.     In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024].     Available: https://en.wikipedia.org/wiki/Brownian_motion</li> </ol> <p>1D Brownian Motion</p> <p>The dimsion of our Brownian motion is specified by the dimension of the initial condition.</p> <p>To simulate a 1D Browian motion, we define the system and initial condition:</p> <pre><code>system = {\n    \"sigma\": 1,\n    \"delta_t\": 1,\n}\n\ninitial_condition = {\n    \"x0\": 0\n}\n</code></pre> <p>The Brownian motion can be simulated using</p> <pre><code>bm = BrownianMotion(system=system, initial_condition=initial_condition)\n\nbm(n_steps=100)\n</code></pre> <p>2D Brownian Motion</p> <p>To simulate a 2D Browian motion,</p> <pre><code>system = {\n    \"sigma\": 1,\n    \"delta_t\": 1,\n}\n\ninitial_condition = {\n    \"x0\": [0, 0]\n}\n\nbm = BrownianMotion(system=system, initial_condition=initial_condition)\n\nbm(n_steps=100)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>Mapping[str, float]</code> <p>the Brownian motion system definition</p> required <code>initial_condition</code> <code>Mapping[str, float] | None</code> <p>the initial condition for the simulation</p> <code>None</code> Source code in <code>hamilflow/models/brownian_motion.py</code> <pre><code>class BrownianMotion:\n    r\"\"\"Brownian motion describes motion of small particles\n    with stochastic forces applied to them.\n    The math of Brownian motion can be modeled\n    with Wiener process.\n\n    For consistency, we always use\n    $\\mathbf x$ for displacement, and\n    $t$ for steps. The model we are using is\n\n    $$\n    \\begin{align}\n    \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) +\n    \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t})\n    \\end{align}\n    $$\n\n    References:\n\n    1. Brownian motion and random walks. [cited 13 Mar 2024].\n        Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html\n    2. Contributors to Wikimedia projects. Brownian motion.\n        In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024].\n        Available: https://en.wikipedia.org/wiki/Brownian_motion\n\n\n    !!! example \"1D Brownian Motion\"\n\n        The dimsion of our Brownian motion is specified by\n        the dimension of the initial condition.\n\n        To simulate a 1D Browian motion, we define the system and initial condition:\n\n        ```python\n        system = {\n            \"sigma\": 1,\n            \"delta_t\": 1,\n        }\n\n        initial_condition = {\n            \"x0\": 0\n        }\n        ```\n\n        The Brownian motion can be simulated using\n\n        ```python\n        bm = BrownianMotion(system=system, initial_condition=initial_condition)\n\n        bm(n_steps=100)\n        ```\n\n    !!! example \"2D Brownian Motion\"\n\n        To simulate a 2D Browian motion,\n\n        ```python\n        system = {\n            \"sigma\": 1,\n            \"delta_t\": 1,\n        }\n\n        initial_condition = {\n            \"x0\": [0, 0]\n        }\n\n        bm = BrownianMotion(system=system, initial_condition=initial_condition)\n\n        bm(n_steps=100)\n        ```\n\n    :param system: the Brownian motion system definition\n    :param initial_condition: the initial condition for the simulation\n    \"\"\"\n\n    def __init__(\n        self,\n        system: Mapping[str, float],\n        initial_condition: Mapping[str, float] | None = None,\n    ):\n        initial_condition = initial_condition or {}\n        self.system = BrownianMotionSystem.model_validate(system)\n        self.initial_condition = BrownianMotionIC.model_validate(initial_condition)\n\n    @property\n    def dim(self) -&gt; int:\n        \"\"\"Dimension of the Brownian motion\"\"\"\n        return self.initial_condition.x0.size\n\n    @property\n    def _axis_names(self) -&gt; list[str]:\n        return [f\"x_{i}\" for i in range(self.dim)]\n\n    def _trajectory(self, n_new_steps: int, seed: int) -&gt; np.ndarray:\n        \"\"\"The trajectory of the particle.\n\n        We first compute the delta displacement in each step.\n        With the displacement at each step, we perform a cumsum\n        including the initial coordinate to get the displacement at each step.\n\n        :param n_new_steps: number of new steps to simulate, excluding the initial step.\n        :param seed: seed for the random generator.\n        \"\"\"\n        step_history = sp.stats.norm.rvs(\n            size=(n_new_steps, self.dim) if self.dim &gt; 1 else n_new_steps,\n            scale=self.system.gaussian_scale,\n            random_state=np.random.RandomState(seed=seed),\n        )\n\n        step_history = np.concatenate(\n            (np.expand_dims(self.initial_condition.x0, axis=0), step_history)\n        )\n\n        trajectory = np.cumsum(step_history, axis=0)\n\n        return trajectory\n\n    def __call__(self, n_steps: int, seed: int = 42) -&gt; pd.DataFrame:\n        \"\"\"Simulate the coordinates of the particle\n\n        :param n_steps: total number of steps to be simulated, including the inital step.\n        :param seed: random generator seed for the stochastic process.\n            Use it to reproduce results.\n        \"\"\"\n        trajectory = self._trajectory(n_new_steps=n_steps - 1, seed=seed)\n\n        df = pd.DataFrame(trajectory, columns=self._axis_names)\n\n        df[\"t\"] = np.arange(0, n_steps) * self.system.delta_t\n\n        return df\n</code></pre>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotion.dim","title":"<code>dim: int</code>  <code>property</code>","text":"<p>Dimension of the Brownian motion</p>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotion.__call__","title":"<code>__call__(n_steps, seed=42)</code>","text":"<p>Simulate the coordinates of the particle</p> <p>Parameters:</p> Name Type Description Default <code>n_steps</code> <code>int</code> <p>total number of steps to be simulated, including the inital step.</p> required <code>seed</code> <code>int</code> <p>random generator seed for the stochastic process. Use it to reproduce results.</p> <code>42</code> Source code in <code>hamilflow/models/brownian_motion.py</code> <pre><code>def __call__(self, n_steps: int, seed: int = 42) -&gt; pd.DataFrame:\n    \"\"\"Simulate the coordinates of the particle\n\n    :param n_steps: total number of steps to be simulated, including the inital step.\n    :param seed: random generator seed for the stochastic process.\n        Use it to reproduce results.\n    \"\"\"\n    trajectory = self._trajectory(n_new_steps=n_steps - 1, seed=seed)\n\n    df = pd.DataFrame(trajectory, columns=self._axis_names)\n\n    df[\"t\"] = np.arange(0, n_steps) * self.system.delta_t\n\n    return df\n</code></pre>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotionIC","title":"<code>BrownianMotionIC</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The initial condition for a Brownian motion</p> <p>Attributes:</p> Name Type Description <code>x0</code> <code>float | Sequence[float]</code> <p>initial displacement of the particle, the diminsion of this initial condition determines the dimension of the model too.</p> Source code in <code>hamilflow/models/brownian_motion.py</code> <pre><code>class BrownianMotionIC(BaseModel):\n    \"\"\"The initial condition for a Brownian motion\n\n    :cvar x0: initial displacement of the particle,\n        the diminsion of this initial condition determines\n        the dimension of the model too.\n    \"\"\"\n\n    x0: float | Sequence[float] = Field(default=1.0)\n\n    @field_validator(\"x0\")\n    @classmethod\n    def check_x0_types(cls, v: float | Sequence[float]) -&gt; np.ndarray:\n        if not isinstance(v, (float, int, Sequence)):\n            # TODO I do not think this raise can be reached\n            raise ValueError(f\"Value of x0 should be int/float/list of int/float: {v=}\")\n\n        return np.array(v, copy=False)\n</code></pre>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotionSystem","title":"<code>BrownianMotionSystem</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Definition of the Brownian Motion system</p> <p>For consistency, we always use \\(\\mathbf x\\) for displacement, and \\(t\\) for steps. The model we are using is</p> \\[ \\begin{align} \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) + \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t}) \\end{align} \\] <p>References:</p> <ol> <li>Brownian motion and random walks. [cited 13 Mar 2024].     Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html</li> <li>Contributors to Wikimedia projects. Brownian motion.     In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024].     Available: https://en.wikipedia.org/wiki/Brownian_motion</li> </ol> <p>Attributes:</p> Name Type Description <code>sigma</code> <code>float</code> <p>base standard deviation to be used to compute the variance</p> <code>delta_t</code> <code>float</code> <p>time granunality of the motion</p> Source code in <code>hamilflow/models/brownian_motion.py</code> <pre><code>class BrownianMotionSystem(BaseModel):\n    r\"\"\"Definition of the Brownian Motion system\n\n    For consistency, we always use\n    $\\mathbf x$ for displacement, and\n    $t$ for steps. The model we are using is\n\n    $$\n    \\begin{align}\n    \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) +\n    \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t})\n    \\end{align}\n    $$\n\n    References:\n\n    1. Brownian motion and random walks. [cited 13 Mar 2024].\n        Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html\n    2. Contributors to Wikimedia projects. Brownian motion.\n        In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024].\n        Available: https://en.wikipedia.org/wiki/Brownian_motion\n\n    :cvar sigma: base standard deviation\n        to be used to compute the variance\n    :cvar delta_t: time granunality of the motion\n    \"\"\"\n\n    sigma: float = Field(ge=0.0)\n    delta_t: float = Field(ge=0.0, default=1.0)\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def gaussian_scale(self) -&gt; float:\n        \"\"\"The scale (standard deviation) of the Gaussian term\n        in Brownian motion\n        \"\"\"\n        return self.sigma**2 * self.delta_t\n</code></pre>"},{"location":"references/models/brownian_motion/#hamilflow.models.brownian_motion.BrownianMotionSystem.gaussian_scale","title":"<code>gaussian_scale: float</code>  <code>cached</code> <code>property</code>","text":"<p>The scale (standard deviation) of the Gaussian term in Brownian motion</p>"},{"location":"references/models/harmonic_oscillator/","title":"Harmonic Oscillator","text":""},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.ComplexSimpleHarmonicOscillator","title":"<code>ComplexSimpleHarmonicOscillator</code>","text":"<p>Generate time series data for a complex simple harmonic oscillator.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>Mapping[str, float]</code> <p>all the params that defines the complex harmonic oscillator.</p> required <code>initial_condition</code> <code>Mapping[str, tuple[float, float]]</code> <p>the initial condition of the complex harmonic oscillator.</p> required Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class ComplexSimpleHarmonicOscillator:\n    r\"\"\"Generate time series data for a complex simple harmonic oscillator.\n\n    :param system: all the params that defines the complex harmonic oscillator.\n    :param initial_condition: the initial condition of the complex harmonic oscillator.\n    \"\"\"\n\n    def __init__(\n        self,\n        system: Mapping[str, float],\n        initial_condition: Mapping[str, tuple[float, float]],\n    ) -&gt; None:\n        self.system = HarmonicOscillatorSystem.model_validate(system)\n        self.initial_condition = ComplexSimpleHarmonicOscillatorIC.model_validate(\n            initial_condition\n        )\n        if self.system.type != \"simple\":\n            raise ValueError(\n                f\"System is not a Simple Harmonic Oscillator: {self.system}\"\n            )\n\n    @cached_property\n    def definition(\n        self,\n    ) -&gt; dict[str, dict[str, float | tuple[float, float]]]:\n        \"\"\"model params and initial conditions defined as a dictionary.\"\"\"\n\n        return dict(\n            system=self.system.model_dump(),\n            initial_condition=self.initial_condition.model_dump(),\n        )\n\n    def _z(\n        self, t: \"Sequence[float] | ArrayLike[float] | ArrayLike[float]\"\n    ) -&gt; ArrayLike:\n        r\"\"\"Solution to complex simple harmonic oscillators:\n\n        $$\n        x(t) = x_+ \\exp(-\\mathbb{i} (\\omega t + \\phi_+)) + x_- \\exp(+\\mathbb{i} (\\omega t + \\phi_-)).\n        $$\n        \"\"\"\n        t = np.array(t, copy=False)\n        omega = self.system.omega\n        x0, phi = self.initial_condition.x0, self.initial_condition.phi\n        phases = -omega * t - phi[0], omega * t + phi[1]\n        return x0[0] * np.exp(1j * phases[0]) + x0[1] * np.exp(1j * phases[1])\n\n    def __call__(\n        self, t: \"Sequence[float] | ArrayLike[float] | ArrayLike[float]\"\n    ) -&gt; pd.DataFrame:\n        \"\"\"Generate time series data for the harmonic oscillator.\n\n        Returns a list of floats representing the displacement at each time.\n\n        :param t: time(s).\n        \"\"\"\n        t = t if isinstance(t, (Sequence, np.ndarray)) else [t]\n        data = self._z(t)\n\n        return pd.DataFrame({\"t\": t, \"z\": data})\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.ComplexSimpleHarmonicOscillator.definition","title":"<code>definition: dict[str, dict[str, float | tuple[float, float]]]</code>  <code>cached</code> <code>property</code>","text":"<p>model params and initial conditions defined as a dictionary.</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.ComplexSimpleHarmonicOscillator.__call__","title":"<code>__call__(t)</code>","text":"<p>Generate time series data for the harmonic oscillator.</p> <p>Returns a list of floats representing the displacement at each time.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Sequence[float] | ArrayLike[float] | ArrayLike[float]</code> <p>time(s).</p> required Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def __call__(\n    self, t: \"Sequence[float] | ArrayLike[float] | ArrayLike[float]\"\n) -&gt; pd.DataFrame:\n    \"\"\"Generate time series data for the harmonic oscillator.\n\n    Returns a list of floats representing the displacement at each time.\n\n    :param t: time(s).\n    \"\"\"\n    t = t if isinstance(t, (Sequence, np.ndarray)) else [t]\n    data = self._z(t)\n\n    return pd.DataFrame({\"t\": t, \"z\": data})\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.ComplexSimpleHarmonicOscillatorIC","title":"<code>ComplexSimpleHarmonicOscillatorIC</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The initial condition for a complex harmonic oscillator</p> <p>Attributes:</p> Name Type Description <code>x0</code> <code>tuple[float, float]</code> <p>the initial displacements</p> <code>phi</code> <code>tuple[float, float]</code> <p>initial phases</p> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class ComplexSimpleHarmonicOscillatorIC(BaseModel):\n    \"\"\"The initial condition for a complex harmonic oscillator\n\n    :cvar x0: the initial displacements\n    :cvar phi: initial phases\n    \"\"\"\n\n    x0: tuple[float, float] = Field()\n    phi: tuple[float, float] = Field(default=(0, 0))\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.DampedHarmonicOscillator","title":"<code>DampedHarmonicOscillator</code>","text":"<p>             Bases: <code>HarmonicOscillatorBase</code></p> <p>Generate time series data for a damped harmonic oscillator.</p> <p>The equation for a general un-driven harmonic oscillator is<sup>1</sup><sup>2</sup></p> \\[ \\frac{\\mathrm d x^2}{\\mathrm d t^2} + 2\\zeta \\omega \\frac{\\mathrm d x}{\\mathrm dt} + \\omega^2 x = 0, \\] <p>where \\(x\\) is the displacement, \\(\\omega\\) is the angular frequency of an undamped oscillator (\\(\\zeta=0\\)), and \\(\\zeta\\) is the damping ratio.</p> <p>The solution to the above harmonic oscillator is</p> \\[ x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)     e^{-\\zeta \\omega t}, \\] <p>where</p> \\[ \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}. \\] <p>To use this generator,</p> <pre><code>params = {\"omega\": omega, \"zeta\"=0.2}\n\nho = DampedHarmonicOscillator(params=params)\n\ndf = ho(n_periods=1, n_samples_per_period=10)\n</code></pre> <p><code>df</code> will be a pandas dataframe with two columns: <code>t</code> and <code>x</code>.</p> <ol> <li> <p>Contributors to Wikimedia projects. Harmonic oscillator.         In: Wikipedia [Internet]. 18 Feb 2024 [cited 20 Feb 2024].         Available: https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator \u21a9</p> </li> <li> <p>Libretexts. 5.3: General Solution for the Damped Harmonic Oscillator. Libretexts. 13 Apr 2021.             Available: https://t.ly/cWTIo. Accessed 20 Feb 2024.\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>Mapping[str, float]</code> <p>all the params that defines the harmonic oscillator.</p> required <code>initial_condition</code> <code>Mapping[str, float] | None</code> <p>the initial condition of the harmonic oscillator.</p> <code>None</code> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class DampedHarmonicOscillator(HarmonicOscillatorBase):\n    r\"\"\"Generate time series data for a [damped harmonic oscillator](https://en.wikipedia.org/wiki/Harmonic_oscillator).\n\n    The equation for a general un-driven harmonic oscillator is[^wiki_ho][^libretext_ho]\n\n    $$\n    \\frac{\\mathrm d x^2}{\\mathrm d t^2} + 2\\zeta \\omega \\frac{\\mathrm d x}{\\mathrm dt} + \\omega^2 x = 0,\n    $$\n\n    where $x$ is the displacement, $\\omega$ is the angular frequency of an undamped oscillator ($\\zeta=0$),\n    and $\\zeta$ is the damping ratio.\n\n    [^wiki_ho]: Contributors to Wikimedia projects. Harmonic oscillator.\n                In: Wikipedia [Internet]. 18 Feb 2024 [cited 20 Feb 2024].\n                Available: https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator\n\n    [^libretext_ho]: Libretexts. 5.3: General Solution for the Damped Harmonic Oscillator. Libretexts. 13 Apr 2021.\n                    Available: https://t.ly/cWTIo. Accessed 20 Feb 2024.\n\n\n    The solution to the above harmonic oscillator is\n\n    $$\n    x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n        e^{-\\zeta \\omega t},\n    $$\n\n    where\n\n    $$\n    \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n    $$\n\n    To use this generator,\n\n    ```python\n    params = {\"omega\": omega, \"zeta\"=0.2}\n\n    ho = DampedHarmonicOscillator(params=params)\n\n    df = ho(n_periods=1, n_samples_per_period=10)\n    ```\n\n    `df` will be a pandas dataframe with two columns: `t` and `x`.\n\n    :param system: all the params that defines the harmonic oscillator.\n    :param initial_condition: the initial condition of the harmonic oscillator.\n    \"\"\"\n\n    def __init__(\n        self,\n        system: Mapping[str, float],\n        initial_condition: Mapping[str, float] | None = None,\n    ) -&gt; None:\n        super().__init__(system, initial_condition)\n        if self.system.type == \"simple\":\n            raise ValueError(\n                f\"System is not a Damped Harmonic Oscillator: {self.system}\\n\"\n                f\"This is a simple harmonic oscillator, use `SimpleHarmonicOscillator`.\"\n            )\n\n    def _x_under_damped(self, t: \"Sequence[float] | ArrayLike[float]\") -&gt; ArrayLike:\n        r\"\"\"Solution to under damped harmonic oscillators:\n\n        $$\n        x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n        e^{-\\zeta \\omega t},\n        $$\n\n        where\n\n        $$\n        \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n        $$\n        \"\"\"\n        omega_damp = self.system.omega * np.sqrt(1 - self.system.zeta)\n        return (\n            self.initial_condition.x0 * np.cos(omega_damp * t)\n            + (\n                self.system.zeta * self.system.omega * self.initial_condition.x0\n                + self.initial_condition.v0\n            )\n            / omega_damp\n            * np.sin(omega_damp * t)\n        ) * np.exp(-self.system.zeta * self.system.omega * t)\n\n    def _x_critical_damped(self, t: \"Sequence[float] | ArrayLike[float]\") -&gt; ArrayLike:\n        r\"\"\"Solution to critical damped harmonic oscillators:\n\n        $$\n        x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n        e^{-\\zeta \\omega t},\n        $$\n\n        where\n\n        $$\n        \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n        $$\n        \"\"\"\n        return self.initial_condition.x0 * np.exp(\n            -self.system.zeta * self.system.omega * t\n        )\n\n    def _x_over_damped(self, t: \"Sequence[float] | ArrayLike[float]\") -&gt; ArrayLike:\n        r\"\"\"Solution to over harmonic oscillators:\n\n        $$\n        x(t) = \\left( x_0 \\cosh(\\Gamma t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Gamma} \\sinh(\\Gamma t) \\right)\n        e^{-\\zeta \\omega t},\n        $$\n\n        where\n\n        $$\n        \\Gamma = \\omega\\sqrt{ \\zeta^2 - 1 }.\n        $$\n        \"\"\"\n        gamma_damp = self.system.omega * np.sqrt(self.system.zeta - 1)\n\n        return (\n            self.initial_condition.x0 * np.cosh(gamma_damp * t)\n            + (\n                self.system.zeta * self.system.omega * self.initial_condition.x0\n                + self.initial_condition.v0\n            )\n            / gamma_damp\n            * np.sinh(gamma_damp * t)\n        ) * np.exp(-self.system.zeta * self.system.omega * t)\n\n    def _x(self, t: \"Sequence[float] | ArrayLike[float]\") -&gt; ArrayLike:\n        r\"\"\"Solution to damped harmonic oscillators.\"\"\"\n        t = np.array(t, copy=False)\n        if self.system.type == \"under_damped\":\n            x = self._x_under_damped(t)\n        elif self.system.type == \"over_damped\":\n            x = self._x_over_damped(t)\n        elif self.system.type == \"critical_damped\":\n            x = self._x_critical_damped(t)\n        else:\n            raise ValueError(\n                \"System type is not damped harmonic oscillator: {self.system.type}\"\n            )\n\n        return x\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorBase","title":"<code>HarmonicOscillatorBase</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class to generate time series data for a harmonic oscillator.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>Mapping[str, float]</code> <p>all the params that defines the harmonic oscillator.</p> required <code>initial_condition</code> <code>Mapping[str, float] | None</code> <p>the initial condition of the harmonic oscillator.</p> <code>None</code> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class HarmonicOscillatorBase(ABC):\n    r\"\"\"Base class to generate time series data\n    for a [harmonic oscillator](https://en.wikipedia.org/wiki/Harmonic_oscillator).\n\n    :param system: all the params that defines the harmonic oscillator.\n    :param initial_condition: the initial condition of the harmonic oscillator.\n    \"\"\"\n\n    def __init__(\n        self,\n        system: Mapping[str, float],\n        initial_condition: Mapping[str, float] | None = None,\n    ) -&gt; None:\n        initial_condition = initial_condition or {}\n        self.system = HarmonicOscillatorSystem.model_validate(system)\n        self.initial_condition = HarmonicOscillatorIC.model_validate(initial_condition)\n\n    @cached_property\n    def definition(self) -&gt; dict[str, dict[str, float]]:\n        \"\"\"model params and initial conditions defined as a dictionary.\"\"\"\n        return {\n            \"system\": self.system.model_dump(),\n            \"initial_condition\": self.initial_condition.model_dump(),\n        }\n\n    @abstractmethod\n    def _x(self, t: \"Sequence[float] | ArrayLike[float]\") -&gt; ArrayLike:\n        r\"\"\"Solution to simple harmonic oscillators.\"\"\"\n        ...\n\n    def __call__(self, n_periods: int, n_samples_per_period: int) -&gt; pd.DataFrame:\n        \"\"\"Generate time series data for the harmonic oscillator.\n\n        Returns a list of floats representing the displacement at each time step.\n\n        :param n_periods: Number of periods to generate.\n        :param n_samples_per_period: Number of samples per period.\n        \"\"\"\n        time_delta = self.system.period / n_samples_per_period\n        time_steps = np.arange(0, n_periods * n_samples_per_period) * time_delta\n\n        data = self._x(time_steps)\n\n        return pd.DataFrame({\"t\": time_steps, \"x\": data})\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorBase.definition","title":"<code>definition: dict[str, dict[str, float]]</code>  <code>cached</code> <code>property</code>","text":"<p>model params and initial conditions defined as a dictionary.</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorBase.__call__","title":"<code>__call__(n_periods, n_samples_per_period)</code>","text":"<p>Generate time series data for the harmonic oscillator.</p> <p>Returns a list of floats representing the displacement at each time step.</p> <p>Parameters:</p> Name Type Description Default <code>n_periods</code> <code>int</code> <p>Number of periods to generate.</p> required <code>n_samples_per_period</code> <code>int</code> <p>Number of samples per period.</p> required Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def __call__(self, n_periods: int, n_samples_per_period: int) -&gt; pd.DataFrame:\n    \"\"\"Generate time series data for the harmonic oscillator.\n\n    Returns a list of floats representing the displacement at each time step.\n\n    :param n_periods: Number of periods to generate.\n    :param n_samples_per_period: Number of samples per period.\n    \"\"\"\n    time_delta = self.system.period / n_samples_per_period\n    time_steps = np.arange(0, n_periods * n_samples_per_period) * time_delta\n\n    data = self._x(time_steps)\n\n    return pd.DataFrame({\"t\": time_steps, \"x\": data})\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorIC","title":"<code>HarmonicOscillatorIC</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The initial condition for a harmonic oscillator</p> <p>Attributes:</p> Name Type Description <code>x0</code> <code>float</code> <p>the initial displacement</p> <code>v0</code> <code>float</code> <p>the initial velocity</p> <code>phi</code> <code>float</code> <p>initial phase</p> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class HarmonicOscillatorIC(BaseModel):\n    \"\"\"The initial condition for a harmonic oscillator\n\n    :cvar x0: the initial displacement\n    :cvar v0: the initial velocity\n    :cvar phi: initial phase\n    \"\"\"\n\n    x0: float = Field(default=1.0)\n    v0: float = Field(default=0.0)\n    phi: float = Field(default=0.0)\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem","title":"<code>HarmonicOscillatorSystem</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The params for the harmonic oscillator</p> <p>Attributes:</p> Name Type Description <code>omega</code> <code>float</code> <p>angular frequency of the harmonic oscillator</p> <code>zeta</code> <code>float</code> <p>damping ratio</p> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class HarmonicOscillatorSystem(BaseModel):\n    \"\"\"The params for the harmonic oscillator\n\n    :cvar omega: angular frequency of the harmonic oscillator\n    :cvar zeta: damping ratio\n    \"\"\"\n\n    omega: float = Field()\n    zeta: float = Field(default=0.0)\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def period(self) -&gt; float:\n        \"\"\"period of the oscillator\"\"\"\n        return 2 * np.pi / self.omega\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def frequency(self) -&gt; float:\n        \"\"\"frequency of the oscillator\"\"\"\n        return 1 / self.period\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def type(\n        self,\n    ) -&gt; Literal[\"simple\", \"under_damped\", \"critical_damped\", \"over_damped\"]:\n        \"\"\"which type of harmonic oscillators\"\"\"\n        if self.zeta == 0:\n            return \"simple\"\n        elif self.zeta &lt; 1:\n            return \"under_damped\"\n        elif self.zeta == 1:\n            return \"critical_damped\"\n        else:\n            return \"over_damped\"\n\n    @field_validator(\"zeta\")\n    @classmethod\n    def check_zeta_non_negative(cls, v: float) -&gt; float:\n        if v &lt; 0:\n            raise ValueError(f\"Value of zeta should be positive: {v=}\")\n\n        return v\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem.frequency","title":"<code>frequency: float</code>  <code>cached</code> <code>property</code>","text":"<p>frequency of the oscillator</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem.period","title":"<code>period: float</code>  <code>cached</code> <code>property</code>","text":"<p>period of the oscillator</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem.type","title":"<code>type: Literal['simple', 'under_damped', 'critical_damped', 'over_damped']</code>  <code>cached</code> <code>property</code>","text":"<p>which type of harmonic oscillators</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.SimpleHarmonicOscillator","title":"<code>SimpleHarmonicOscillator</code>","text":"<p>             Bases: <code>HarmonicOscillatorBase</code></p> <p>Generate time series data for a simple harmonic oscillator.</p> <p>In a one dimensional world, a mass \\(m\\), driven by a force \\(F=-kx\\), is described as</p> \\[ \\begin{align} F &amp;= - k x \\\\ F &amp;= m a \\end{align} \\] <p>The mass behaves like a simple harmonic oscillator.</p> <p>In general, the solution to a simple harmonic oscillator is</p> \\[ x(t) = A \\cos(\\omega t + \\phi), \\] <p>where \\(\\omega\\) is the angular frequency, \\(\\phi\\) is the initial phase, and \\(A\\) is the amplitude.</p> <p>To use this generator,</p> <pre><code>params = {\"omega\": omega}\n\nho = SimpleHarmonicOscillator(params=params)\n\ndf = ho(n_periods=1, n_samples_per_period=10)\n</code></pre> <p><code>df</code> will be a pandas dataframe with two columns: <code>t</code> and <code>x</code>.</p> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class SimpleHarmonicOscillator(HarmonicOscillatorBase):\n    r\"\"\"Generate time series data for a\n    [simple harmonic oscillator](https://en.wikipedia.org/wiki/Harmonic_oscillator).\n\n\n    In a one dimensional world, a mass $m$, driven by a force $F=-kx$, is described as\n\n    $$\n    \\begin{align}\n    F &amp;= - k x \\\\\n    F &amp;= m a\n    \\end{align}\n    $$\n\n    The mass behaves like a simple harmonic oscillator.\n\n    In general, the solution to a simple harmonic oscillator is\n\n    $$\n    x(t) = A \\cos(\\omega t + \\phi),\n    $$\n\n    where $\\omega$ is the angular frequency, $\\phi$ is the initial phase, and $A$ is the amplitude.\n\n\n    To use this generator,\n\n    ```python\n    params = {\"omega\": omega}\n\n    ho = SimpleHarmonicOscillator(params=params)\n\n    df = ho(n_periods=1, n_samples_per_period=10)\n    ```\n\n    `df` will be a pandas dataframe with two columns: `t` and `x`.\n    \"\"\"\n\n    def __init__(\n        self,\n        system: Mapping[str, float],\n        initial_condition: Mapping[str, float] | None = None,\n    ) -&gt; None:\n        super().__init__(system, initial_condition)\n        if self.system.type != \"simple\":\n            raise ValueError(\n                f\"System is not a Simple Harmonic Oscillator: {self.system}\"\n            )\n\n    def _x(self, t: \"Sequence[float] | ArrayLike[float]\") -&gt; np.ndarray:\n        r\"\"\"Solution to simple harmonic oscillators:\n\n        $$\n        x(t) = x_0 \\cos(\\omega t + \\phi).\n        $$\n        \"\"\"\n        return self.initial_condition.x0 * np.cos(\n            self.system.omega * np.array(t, copy=False) + self.initial_condition.phi\n        )\n</code></pre>"},{"location":"references/models/pendulum/","title":"Pendulum","text":""},{"location":"references/models/pendulum/#hamilflow.models.pendulum.Pendulum","title":"<code>Pendulum</code>","text":"<p>Generate time series data for a pendulum.</p> <p>We describe a generic pendulum system by the Lagrangian action $$ S_L[\\theta] = I \\int_{t_0}^{t_1} \\mathbb{d}t \\left\\{\\frac{1}{2} \\dot\\theta^2 + \\omega_0^2 \\cos\\theta \\right\\}\\,, $$ where \\(\\theta\\) is the angle from the vertical to the pendulum; \\(I\\) is the inertia parameter introduced for dimensional reasons, and \\(\\omega_0\\) the frequency parameter.</p> <p>Details are collected in the tutorial.</p> Source code in <code>hamilflow/models/pendulum.py</code> <pre><code>class Pendulum:\n    r\"\"\"Generate time series data for a pendulum.\n\n    We describe a generic pendulum system by the Lagrangian action\n    $$\n    S_L\\[\\theta\\] = I \\int_{t_0}^{t_1} \\mathbb{d}t\n    \\left\\\\{\\frac{1}{2} \\dot\\theta^2 + \\omega_0^2 \\cos\\theta \\right\\\\}\\,,\n    $$\n    where $\\theta$ is the _angle_ from the vertical to the pendulum;\n    $I$ is the _inertia parameter_ introduced for dimensional reasons,\n    and $\\omega_0$ the _frequency parameter_.\n\n    Details are collected in the tutorial.\n    \"\"\"\n\n    def __init__(\n        self,\n        system: float | Mapping[str, float],\n        initial_condition: float | Mapping[str, float],\n    ) -&gt; None:\n        if isinstance(system, (float, int)):\n            system = {\"omega0\": system}\n        if isinstance(initial_condition, (float, int)):\n            initial_condition = {\"theta0\": initial_condition}\n        self.system = PendulumSystem.model_validate(system)\n        self.initial_condition = PendulumIC.model_validate(initial_condition)\n\n    @cached_property\n    def definition(self) -&gt; dict[str, float]:\n        \"\"\"Model params and initial conditions defined as a dictionary.\"\"\"\n        return dict(\n            system=self.system.model_dump(),\n            initial_condition=self.initial_condition.model_dump(),\n        )\n\n    @property\n    def omega0(self) -&gt; float:\n        return self.system.omega0\n\n    @property\n    def _k(self) -&gt; float:\n        return self.initial_condition.k\n\n    @property\n    def _math_m(self) -&gt; float:\n        return self._k**2\n\n    @cached_property\n    def freq(self) -&gt; float:\n        r\"\"\"Frequency.\n\n        :return: $\\frac{\\pi}{2K(k^2)}\\omega_0$, where\n        $K(m)$ is [Legendre's complete elliptic integral of the first kind](https://dlmf.nist.gov/19.2#E8)\n        \"\"\"\n        return math.pi * self.omega0 / (2 * ellipk(self._math_m))\n\n    @cached_property\n    def period(self) -&gt; float:\n        r\"\"\"Period.\n\n        :return: $\\frac{4K(k^2)}{\\omega_0}$, where\n        $K(m)$ is [Legendre's complete elliptic integral of the first kind](https://dlmf.nist.gov/19.2#E8)\n        \"\"\"\n        return 4 * ellipk(self._math_m) / self.omega0\n\n    def _math_u(self, t: \"Sequence[float] | ArrayLike[float]\") -&gt; np.ndarray[float]:\n        return self.omega0 * np.array(t, copy=False)\n\n    def u(self, t: \"Sequence[float] | ArrayLike[float]\") -&gt; np.ndarray[float]:\n        r\"\"\"The convenient generalised coordinate $u$,\n        $\\sin u \\coloneqq \\frac{\\sin\\frac{\\theta}{2}}{\\sin\\frac{\\theta_0}{2}}$.\n\n        :param t: time\n        :return: $u(t) = \\mathrm{am}\\!\\big(\\omega_0 t + K(k^2), k^2\\big)$, where\n        $\\mathrm{am}(x, k)$ is [Jacobi's amplitude function](https://dlmf.nist.gov/22.16#E1),\n        $K(m)$ is [Legendre's complete elliptic integral of the first kind](https://dlmf.nist.gov/19.2#E8)\n        \"\"\"\n        _, _, _, ph = ellipj(self._math_u(t) + ellipk(self._math_m), self._math_m)\n\n        return ph\n\n    def theta(self, t: \"Sequence[float] | ArrayLike[float]\") -&gt; np.ndarray[float]:\n        r\"\"\"Angle $\\theta$.\n\n        :param t: time\n        :return: $\\theta(t) = 2\\arcsin\\!\\big(k\\cdot\\mathrm{cd}(\\omega_0 t, k^2)\\big)$, where\n        $\\mathrm{cd}(z, k)$ is a [Jacobian elliptic function](https://dlmf.nist.gov/22.2#E8)\n        \"\"\"\n        _, cn, dn, _ = ellipj(self._math_u(t), self._math_m)\n\n        return 2 * np.arcsin(cn / dn * self._k)\n\n    def __call__(self, n_periods: int, n_samples_per_period: int) -&gt; pd.DataFrame:\n        time_delta = self.period / n_samples_per_period\n        time_steps = np.arange(0, n_periods * n_samples_per_period) * time_delta\n\n        thetas = self.theta(time_steps)\n        us = self.u(time_steps)\n\n        return pd.DataFrame(dict(t=time_steps, x=thetas, u=us))\n</code></pre>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.Pendulum.definition","title":"<code>definition: dict[str, float]</code>  <code>cached</code> <code>property</code>","text":"<p>Model params and initial conditions defined as a dictionary.</p>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.Pendulum.freq","title":"<code>freq: float</code>  <code>cached</code> <code>property</code>","text":"<p>Frequency.</p> <p>Returns:</p> Type Description <code>float</code> <p>\\(\\frac{\\pi}{2K(k^2)}\\omega_0\\), where \\(K(m)\\) is Legendre's complete elliptic integral of the first kind</p>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.Pendulum.period","title":"<code>period: float</code>  <code>cached</code> <code>property</code>","text":"<p>Period.</p> <p>Returns:</p> Type Description <code>float</code> <p>\\(\\frac{4K(k^2)}{\\omega_0}\\), where \\(K(m)\\) is Legendre's complete elliptic integral of the first kind</p>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.Pendulum.theta","title":"<code>theta(t)</code>","text":"<p>Angle \\(\\theta\\).</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Sequence[float] | ArrayLike[float]</code> <p>time</p> required <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>\\(\\theta(t) = 2\\arcsin\\!\\big(k\\cdot\\mathrm{cd}(\\omega_0 t, k^2)\\big)\\), where \\(\\mathrm{cd}(z, k)\\) is a Jacobian elliptic function</p> Source code in <code>hamilflow/models/pendulum.py</code> <pre><code>def theta(self, t: \"Sequence[float] | ArrayLike[float]\") -&gt; np.ndarray[float]:\n    r\"\"\"Angle $\\theta$.\n\n    :param t: time\n    :return: $\\theta(t) = 2\\arcsin\\!\\big(k\\cdot\\mathrm{cd}(\\omega_0 t, k^2)\\big)$, where\n    $\\mathrm{cd}(z, k)$ is a [Jacobian elliptic function](https://dlmf.nist.gov/22.2#E8)\n    \"\"\"\n    _, cn, dn, _ = ellipj(self._math_u(t), self._math_m)\n\n    return 2 * np.arcsin(cn / dn * self._k)\n</code></pre>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.Pendulum.u","title":"<code>u(t)</code>","text":"<p>The convenient generalised coordinate \\(u\\), \\(\\sin u \\coloneqq \\frac{\\sin\\frac{\\theta}{2}}{\\sin\\frac{\\theta_0}{2}}\\).</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Sequence[float] | ArrayLike[float]</code> <p>time</p> required <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>\\(u(t) = \\mathrm{am}\\!\\big(\\omega_0 t + K(k^2), k^2\\big)\\), where \\(\\mathrm{am}(x, k)\\) is Jacobi's amplitude function, \\(K(m)\\) is Legendre's complete elliptic integral of the first kind</p> Source code in <code>hamilflow/models/pendulum.py</code> <pre><code>def u(self, t: \"Sequence[float] | ArrayLike[float]\") -&gt; np.ndarray[float]:\n    r\"\"\"The convenient generalised coordinate $u$,\n    $\\sin u \\coloneqq \\frac{\\sin\\frac{\\theta}{2}}{\\sin\\frac{\\theta_0}{2}}$.\n\n    :param t: time\n    :return: $u(t) = \\mathrm{am}\\!\\big(\\omega_0 t + K(k^2), k^2\\big)$, where\n    $\\mathrm{am}(x, k)$ is [Jacobi's amplitude function](https://dlmf.nist.gov/22.16#E1),\n    $K(m)$ is [Legendre's complete elliptic integral of the first kind](https://dlmf.nist.gov/19.2#E8)\n    \"\"\"\n    _, _, _, ph = ellipj(self._math_u(t) + ellipk(self._math_m), self._math_m)\n\n    return ph\n</code></pre>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.PendulumIC","title":"<code>PendulumIC</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The initial condition for a pendulum.</p> <p>Parameters:</p> Name Type Description Default <code>theta0</code> <p>\\(-\\frac{\\pi}{2} \\le \\theta_0 \\le \\frac{\\pi}{2}\\), the initial angle</p> required Source code in <code>hamilflow/models/pendulum.py</code> <pre><code>class PendulumIC(BaseModel):\n    r\"\"\"The initial condition for a pendulum.\n\n    :param theta0: $-\\frac{\\pi}{2} \\le \\theta_0 \\le \\frac{\\pi}{2}$, the\n    initial angle\n    \"\"\"\n\n    theta0: float = Field(ge=-math.pi / 2, le=math.pi / 2, frozen=True)\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def k(self) -&gt; float:\n        r\"\"\"A convenient number for elliptic functions.\n\n        :return: $\\sin\\frac{\\theta_0}{2}$\n        \"\"\"\n        return math.sin(self.theta0 / 2)\n</code></pre>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.PendulumIC.k","title":"<code>k: float</code>  <code>cached</code> <code>property</code>","text":"<p>A convenient number for elliptic functions.</p> <p>Returns:</p> Type Description <code>float</code> <p>\\(\\sin\\frac{\\theta_0}{2}\\)</p>"},{"location":"references/models/pendulum/#hamilflow.models.pendulum.PendulumSystem","title":"<code>PendulumSystem</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The params for the pendulum.</p> <p>Parameters:</p> Name Type Description Default <code>omega0</code> <p>\\(\\omega_0 \\coloneqq \\sqrt{\\frac{U}{I}} &gt; 0\\), frequency parameter</p> required Source code in <code>hamilflow/models/pendulum.py</code> <pre><code>class PendulumSystem(BaseModel):\n    r\"\"\"The params for the pendulum.\n\n    :param omega0: $\\omega_0 \\coloneqq \\sqrt{\\frac{U}{I}} &gt; 0$, frequency\n    parameter\n    \"\"\"\n\n    omega0: float = Field(gt=0.0, frozen=True)\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>We provide some tutorials to help you get started.</p>"},{"location":"tutorials/brownian_motion/","title":"Brownian Motion","text":"In\u00a0[1]: Copied! <pre>import plotly.express as px\n\nfrom hamilflow.models.brownian_motion import BrownianMotion\n</pre> import plotly.express as px  from hamilflow.models.brownian_motion import BrownianMotion In\u00a0[2]: Copied! <pre>bm_1d = BrownianMotion(\n    system={\n        \"sigma\": 1,\n        \"delta_t\": 1,\n    },\n    initial_condition={\"x0\": 0},\n)\n</pre> bm_1d = BrownianMotion(     system={         \"sigma\": 1,         \"delta_t\": 1,     },     initial_condition={\"x0\": 0}, ) <p>Call the model to generate 1000 steps.</p> In\u00a0[3]: Copied! <pre>df_1d = bm_1d(n_steps=1000)\n</pre> df_1d = bm_1d(n_steps=1000) In\u00a0[4]: Copied! <pre>px.line(df_1d, x=\"t\", y=\"x_0\")\n</pre> px.line(df_1d, x=\"t\", y=\"x_0\") In\u00a0[5]: Copied! <pre>bm_2d = BrownianMotion(\n    system={\n        \"sigma\": 1,\n        \"delta_t\": 1,\n    },\n    initial_condition={\"x0\": [0, 0]},\n)\n</pre> bm_2d = BrownianMotion(     system={         \"sigma\": 1,         \"delta_t\": 1,     },     initial_condition={\"x0\": [0, 0]}, ) <p>We call the model to generate 1000 steps.</p> In\u00a0[6]: Copied! <pre>df_2d = bm_2d(n_steps=500)\n</pre> df_2d = bm_2d(n_steps=500) In\u00a0[7]: Copied! <pre>(\n    px.scatter(df_2d, x=\"x_0\", y=\"x_1\", color=\"t\")\n    .update_traces(\n        mode=\"lines+markers\",\n        marker=dict(\n            size=2.5,\n        ),\n        line=dict(width=1),\n    )\n    .update_yaxes(\n        scaleanchor=\"x\",\n        scaleratio=1,\n    )\n)\n</pre> (     px.scatter(df_2d, x=\"x_0\", y=\"x_1\", color=\"t\")     .update_traces(         mode=\"lines+markers\",         marker=dict(             size=2.5,         ),         line=dict(width=1),     )     .update_yaxes(         scaleanchor=\"x\",         scaleratio=1,     ) ) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/brownian_motion/#brownian-motion","title":"Brownian Motion\u00b6","text":"<p>Brownian motion describes motion of small particles with stochastic forces applied to them. The math of Brownian motion can be modeled with Wiener process. In this tutorial, we take a simple form of the model and treat the stochastic forces as Gaussian.</p> <p>For consistency, we always use $\\mathbf x$ for displacement, and $t$ for steps. The model we are using is</p> <p>$$ \\begin{align} \\mathbf x(t + \\mathrm dt) &amp;= \\mathbf x(t) + \\mathcal{N}(\\mu=0, \\sigma=\\sigma \\sqrt{\\mathrm d t}) \\end{align} $$</p> <p>Read more:</p> <ol> <li>Brownian motion and random walks. [cited 13 Mar 2024]. Available: https://web.mit.edu/8.334/www/grades/projects/projects17/OscarMickelin/brownian.html</li> <li>Contributors to Wikimedia projects. Brownian motion. In: Wikipedia [Internet]. 22 Jan 2024 [cited 13 Mar 2024]. Available: https://en.wikipedia.org/wiki/Brownian_motion</li> </ol> <p><code>hamilflow</code> implemented a Brownian motion model called <code>BrownianMotion</code>.</p>"},{"location":"tutorials/brownian_motion/#1d-brownian-motion","title":"1D Brownian Motion\u00b6","text":""},{"location":"tutorials/brownian_motion/#2d-brownian-motion","title":"2D Brownian Motion\u00b6","text":"<p>Our <code>BrownianMotion</code> model calculates the dimension of the space based on the dimension of the initial condition $x_0$. To create a 2D Brownian motion model, we need the initial condition to be length 2.</p>"},{"location":"tutorials/complex_harmonic_oscillator/","title":"Complex Harmonic Oscillator","text":"In\u00a0[1]: Copied! <pre>import math\n\nimport numpy as np\nfrom plotly import express as px\n\nfrom hamilflow.models.harmonic_oscillator import ComplexSimpleHarmonicOscillator\n</pre> import math  import numpy as np from plotly import express as px  from hamilflow.models.harmonic_oscillator import ComplexSimpleHarmonicOscillator In\u00a0[2]: Copied! <pre>t = np.linspace(0, 3, 257)\nsystem_specs = dict(omega=2 * math.pi)\n</pre> t = np.linspace(0, 3, 257) system_specs = dict(omega=2 * math.pi) In\u00a0[3]: Copied! <pre>csho = ComplexSimpleHarmonicOscillator(system_specs, initial_condition=dict(x0=(1, 0)))\n\ndf = csho(t)\n\narr_z = df[\"z\"].to_numpy(copy=False)\n\npx.line_3d(x=arr_z.real, y=arr_z.imag, z=t, labels=dict(x=\"real\", y=\"imag\", z=\"time\"))\n</pre> csho = ComplexSimpleHarmonicOscillator(system_specs, initial_condition=dict(x0=(1, 0)))  df = csho(t)  arr_z = df[\"z\"].to_numpy(copy=False)  px.line_3d(x=arr_z.real, y=arr_z.imag, z=t, labels=dict(x=\"real\", y=\"imag\", z=\"time\")) In\u00a0[4]: Copied! <pre>csho = ComplexSimpleHarmonicOscillator(system_specs, initial_condition=dict(x0=(0, 1)))\n\ndf = csho(t)\n\narr_z = df[\"z\"].to_numpy(copy=False)\n\npx.line_3d(x=arr_z.real, y=arr_z.imag, z=t, labels=dict(x=\"real\", y=\"imag\", z=\"time\"))\n</pre> csho = ComplexSimpleHarmonicOscillator(system_specs, initial_condition=dict(x0=(0, 1)))  df = csho(t)  arr_z = df[\"z\"].to_numpy(copy=False)  px.line_3d(x=arr_z.real, y=arr_z.imag, z=t, labels=dict(x=\"real\", y=\"imag\", z=\"time\")) In\u00a0[5]: Copied! <pre>csho = ComplexSimpleHarmonicOscillator(\n    system_specs,\n    initial_condition=dict(x0=(math.cos(math.pi / 12), math.sin(math.pi / 12))),\n)\n\ndf = csho(t)\n\narr_z = df[\"z\"].to_numpy(copy=False)\n\npx.line_3d(x=arr_z.real, y=arr_z.imag, z=t, labels=dict(x=\"real\", y=\"imag\", z=\"time\"))\n</pre> csho = ComplexSimpleHarmonicOscillator(     system_specs,     initial_condition=dict(x0=(math.cos(math.pi / 12), math.sin(math.pi / 12))), )  df = csho(t)  arr_z = df[\"z\"].to_numpy(copy=False)  px.line_3d(x=arr_z.real, y=arr_z.imag, z=t, labels=dict(x=\"real\", y=\"imag\", z=\"time\"))"},{"location":"tutorials/complex_harmonic_oscillator/#complex-harmonic-oscillator","title":"Complex Harmonic Oscillator\u00b6","text":"<p>In this tutorial, we show a few interesting examples of the complex simple harmonic oscillator.</p>"},{"location":"tutorials/complex_harmonic_oscillator/#basic-setups","title":"Basic setups\u00b6","text":""},{"location":"tutorials/complex_harmonic_oscillator/#positive-frequency-circular-polarised-mode","title":"Positive-frequency, circular-polarised mode\u00b6","text":"<p>Also known as the left-rotating mode.</p>"},{"location":"tutorials/complex_harmonic_oscillator/#negative-frequency-circular-polarised-mode","title":"Negative-frequency, circular-polarised mode\u00b6","text":"<p>Also known as the right-rotating mode.</p>"},{"location":"tutorials/complex_harmonic_oscillator/#positive-frequency-elliptic-polarised-mode","title":"Positive-frequency, elliptic-polarised mode\u00b6","text":""},{"location":"tutorials/complex_harmonic_oscillator/#end-of-notebook","title":"End of Notebook\u00b6","text":""},{"location":"tutorials/harmonic_oscillator/","title":"Harmonic Oscillators","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport plotly.express as px\n\nfrom hamilflow.models.harmonic_oscillator import (\n    DampedHarmonicOscillator,\n    SimpleHarmonicOscillator,\n)\n</pre> import pandas as pd import plotly.express as px  from hamilflow.models.harmonic_oscillator import (     DampedHarmonicOscillator,     SimpleHarmonicOscillator, ) In\u00a0[2]: Copied! <pre>n_periods = 3\nn_samples_per_period = 200\n</pre> n_periods = 3 n_samples_per_period = 200 In\u00a0[3]: Copied! <pre>sho_omega = 0.5\n\nsho = SimpleHarmonicOscillator(system={\"omega\": sho_omega})\n</pre> sho_omega = 0.5  sho = SimpleHarmonicOscillator(system={\"omega\": sho_omega}) In\u00a0[4]: Copied! <pre>df_sho = sho(n_periods=n_periods, n_samples_per_period=n_samples_per_period)\ndf_sho.head()\n</pre> df_sho = sho(n_periods=n_periods, n_samples_per_period=n_samples_per_period) df_sho.head() Out[4]: t x 0 0.000000 1.000000 1 0.062832 0.999507 2 0.125664 0.998027 3 0.188496 0.995562 4 0.251327 0.992115 In\u00a0[5]: Copied! <pre>px.line(\n    df_sho,\n    x=\"t\",\n    y=\"x\",\n    title=rf\"Simple Harmonic Oscillator (omega = {sho_omega})\",\n    labels={\n        \"x\": r\"Displacement $x(t)$\",\n        \"t\": r\"$t$\",\n    },\n)\n</pre> px.line(     df_sho,     x=\"t\",     y=\"x\",     title=rf\"Simple Harmonic Oscillator (omega = {sho_omega})\",     labels={         \"x\": r\"Displacement $x(t)$\",         \"t\": r\"$t$\",     }, ) In\u00a0[6]: Copied! <pre>dho_systems = {\n    \"Underdamped\": {\"omega\": 0.5, \"zeta\": 0.2},\n    \"Critical Damped\": {\"omega\": 0.5, \"zeta\": 1},\n    \"Overdamped\": {\n        \"omega\": 0.5,\n        \"zeta\": 1.2,\n    },\n}\n\ndfs_dho = []\n\nfor s_name, s in dho_systems.items():\n\n    dfs_dho.append(\n        DampedHarmonicOscillator(system=s)(\n            n_periods=n_periods, n_samples_per_period=n_samples_per_period\n        ).assign(system=rf\"{s_name} (omega = {s.get('omega')}, zeta = {s.get('zeta')})\")\n    )\n\nfig = px.line(\n    pd.concat(dfs_dho),\n    x=\"t\",\n    y=\"x\",\n    color=\"system\",\n    title=rf\"Damped Harmonic Oscillator\",\n    labels={\n        \"x\": r\"Displacement $x(t)$\",\n        \"t\": r\"$t$\",\n    },\n)\nfig.update_layout(legend={\"yanchor\": \"top\", \"y\": -0.2, \"xanchor\": \"left\", \"x\": 0})\n</pre> dho_systems = {     \"Underdamped\": {\"omega\": 0.5, \"zeta\": 0.2},     \"Critical Damped\": {\"omega\": 0.5, \"zeta\": 1},     \"Overdamped\": {         \"omega\": 0.5,         \"zeta\": 1.2,     }, }  dfs_dho = []  for s_name, s in dho_systems.items():      dfs_dho.append(         DampedHarmonicOscillator(system=s)(             n_periods=n_periods, n_samples_per_period=n_samples_per_period         ).assign(system=rf\"{s_name} (omega = {s.get('omega')}, zeta = {s.get('zeta')})\")     )  fig = px.line(     pd.concat(dfs_dho),     x=\"t\",     y=\"x\",     color=\"system\",     title=rf\"Damped Harmonic Oscillator\",     labels={         \"x\": r\"Displacement $x(t)$\",         \"t\": r\"$t$\",     }, ) fig.update_layout(legend={\"yanchor\": \"top\", \"y\": -0.2, \"xanchor\": \"left\", \"x\": 0}) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/harmonic_oscillator/#harmonic-oscillators","title":"Harmonic Oscillators\u00b6","text":"<p>In this tutorial, we demo how to generate data of harmonic oscillators.</p>"},{"location":"tutorials/harmonic_oscillator/#simple-harmonic-oscillator","title":"Simple Harmonic Oscillator\u00b6","text":"<p>For an simple harmonic oscillator, the action of a simple harmonic oscillator is</p> <p>$$S_L[x] = \\int_{t_0}^{t_1} \\mathbb{d}t \\left\\{\\frac{1}{2} m \\dot x^2 - \\frac{1}{2} m \\omega^2 x^2 \\right\\}\\,,$$</p> <p>where the least action principle leads to the following equation of motion,</p> <p>$$ \\ddot x + \\omega^2 x = 0\\,. $$</p> <p>A simple harmonic oscillator is a periodic motion.</p>"},{"location":"tutorials/harmonic_oscillator/#damped-harmonic-oscillator","title":"Damped Harmonic Oscillator\u00b6","text":"<p>A damped harmonic oscillator is a simple harmonic oscillator with damping force that is proportional to its velocity,</p> <p>$$ \\ddot x + \\omega^2 x = - 2\\xi\\omega \\dot x\\,. $$</p> <p>In this section, we demonstrate three scenarios of a damped harmonic oscillator.</p>"},{"location":"tutorials/pendulum/","title":"Pendulum","text":"In\u00a0[1]: Copied! <pre>import math\n\nimport plotly.express as px\n\nfrom hamilflow.models.pendulum import Pendulum\n</pre> import math  import plotly.express as px  from hamilflow.models.pendulum import Pendulum In\u00a0[2]: Copied! <pre>omega0 = 2 * math.pi\ntheta0 = math.pi / 3\n\nn_periods = 2**2\nn_samples_per_period = 2**8\n</pre> omega0 = 2 * math.pi theta0 = math.pi / 3  n_periods = 2**2 n_samples_per_period = 2**8 In\u00a0[3]: Copied! <pre>pen = Pendulum(system=omega0, initial_condition=theta0)\n</pre> pen = Pendulum(system=omega0, initial_condition=theta0) In\u00a0[4]: Copied! <pre>df_pen = pen(n_periods=n_periods, n_samples_per_period=n_samples_per_period)\ndf_pen.head()\n</pre> df_pen = pen(n_periods=n_periods, n_samples_per_period=n_samples_per_period) df_pen.head() Out[4]: t x u 0 0.000000 1.047198 1.570796 1 0.004192 1.046897 1.593608 2 0.008384 1.045996 1.616424 3 0.012576 1.044494 1.639247 4 0.016768 1.042393 1.662082 In\u00a0[5]: Copied! <pre>df_pen.describe()\n</pre> df_pen.describe() Out[5]: t x u count 1024.000000 1.024000e+03 1024.000000 mean 2.144268 2.320193e-17 14.124895 std 1.239809 7.453532e-01 7.261249 min 0.000000 -1.047198e+00 1.570796 25% 1.072134 -7.494689e-01 7.848279 50% 2.144268 -3.535251e-16 14.125761 75% 3.216402 7.494689e-01 20.403244 max 4.288536 1.047198e+00 26.680726 In\u00a0[6]: Copied! <pre>px.line(\n    df_pen,\n    x=\"t\",\n    y=\"x\",\n    title=r\"Simple Harmonic Oscillator ($\\omega_0 = {:.4f})$\".format(omega0),\n    labels=dict(x=r\"Angle $\\theta(t)$\", t=r\"Time $t$\"),\n)\n</pre> px.line(     df_pen,     x=\"t\",     y=\"x\",     title=r\"Simple Harmonic Oscillator ($\\omega_0 = {:.4f})$\".format(omega0),     labels=dict(x=r\"Angle $\\theta(t)$\", t=r\"Time $t$\"), )"},{"location":"tutorials/pendulum/#pendulum","title":"Pendulum\u00b6","text":"<p>In this tutorial, we demonstrate how to generate data of a pendulum, and introduce the mathematics of a pendulum.</p>"},{"location":"tutorials/pendulum/#constants","title":"Constants\u00b6","text":""},{"location":"tutorials/pendulum/#a-pendulum","title":"A pendulum\u00b6","text":""},{"location":"tutorials/pendulum/#data","title":"Data\u00b6","text":""},{"location":"tutorials/pendulum/#plot","title":"Plot\u00b6","text":""},{"location":"tutorials/pendulum/#todo","title":"TODO\u00b6","text":"<ul> <li>Compare with a harmonic oscillator in terms of frequency and profile</li> <li>Animate the plot as a single pendulum</li> <li>Add references to the derivation</li> <li>Complete the derivation</li> </ul>"},{"location":"tutorials/pendulum/#mathematical-physical-description","title":"Mathematical-physical description\u00b6","text":""},{"location":"tutorials/pendulum/#lagrangian-action","title":"Lagrangian action\u00b6","text":"<p>We describe a generic pendulum system by the Lagrangian action $$ S_L[\\theta] \\equiv \\int_{t_0}^{t_1} \\mathbb{d}t\\,L(\\theta, \\dot\\theta) \\eqqcolon I \\int_{t_0}^{t_1} \\mathbb{d}t \\left\\{\\frac{1}{2} \\dot\\theta^2 + \\omega_0^2 \\cos\\theta \\right\\}\\,, $$ where $L$ is the Lagrangian; $\\theta$ is the angle from the vertical to the pendulum as the generalised position; $I$ is the inertia parameter, $\\omega_0$ the frequency parameter, and we also call $U \\coloneqq I\\omega_0^2$ the potential parameter.</p> <p>This setup contains both the single and the physical pendula. For a single pendulum, $$ I = m l^2\\,,\\qquad U = mgl\\,, $$ where $m$ is the mass of the pendulum, $l$ is the length of the rod or cord, and $g$ is the gravitational acceleration.</p>"},{"location":"tutorials/pendulum/#integral-of-motion","title":"Integral of motion\u00b6","text":"<p>The Lagrangian action does not contain time $t$ explicitly. As a result, the system is invariant under a variation of time, or $\\mathbb{\\delta}S / \\mathbb{\\delta}{t} = 0$. This gives an integral of motion $$ \\dot\\theta\\frac{\\partial L}{\\partial \\dot\\theta} - L \\equiv E \\eqqcolon I \\omega_0^2 \\cos\\theta_0\\,, $$ where $\\theta_0$ is the initial angle.</p> <p>Substitution gives $$ \\left(\\frac{\\mathbb{d}t}{\\mathbb{d}\\theta}\\right)^2 = \\frac{1}{2\\omega_0^2} \\frac{1}{\\cos\\theta - \\cos\\theta_0}\\,. $$</p>"},{"location":"tutorials/pendulum/#coordinate-transformation","title":"Coordinate transformation\u00b6","text":"<p>For convenience, introduce the coordinate $u$ and the parameter $k$ $$ \\sin u \\coloneqq \\frac{\\sin\\frac{\\theta}{2}}{k}\\,,\\qquad k \\coloneqq \\sin\\frac{\\theta_0}{2} \\in [-1, 1]\\,. $$ One arrives at $$ \\left(\\frac{\\mathbb{d}t}{\\mathbb{d}u}\\right)^2 = \\frac{1}{\\omega_0^2} \\frac{1}{1-k^2\\sin^2 u}\\,. $$ The square root of the second factor on the right-hand side makes an elliptic integral.</p>"},{"location":"tutorials/pendulum/#end-of-notebook","title":"End of Notebook\u00b6","text":""}]}