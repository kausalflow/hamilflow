{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation for <code>hamilflow</code>","text":"<p>Generating dataset for physical systems.</p>"},{"location":"#development","title":"Development","text":"<p>We use <code>poetry</code> to manage our python environment. Use</p> <pre><code>poetry install\n</code></pre> <p>to install the requirements. Or run</p> <pre><code>poetry install --with test\n</code></pre> <p>to install the base environment and test environment for development.</p> <p>If this is the first you clone the repo and committing code, run</p> <pre><code>pre-commit install\n</code></pre> <p>first.</p>"},{"location":"changelog/","title":"hamilflow Changelog","text":""},{"location":"changelog/#2024-02-18-001","title":"2024-02-18, 0.0.1","text":"<p>Setting up repository.</p>"},{"location":"references/","title":"References","text":""},{"location":"references/models/harmonic_oscillator/","title":"Harmonic Oscillator","text":""},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillator","title":"<code>HarmonicOscillator</code>","text":"<p>Generate time series data for a harmonic oscillator.</p> <p>The equation for a general un-driven harmonic oscillator is<sup>1</sup><sup>2</sup></p> \\[ \\frac{\\mathrm d x^2}{\\mathrm d t^2} + 2\\zeta \\omega \\frac{\\mathrm d x}{\\mathrm dt} + \\omega^2 x = 0, \\] <p>where \\(x\\) is the displacement, \\(\\omega\\) is the angular frequency of an undamped oscillator (\\(\\zeta=0\\)), and \\(\\zeta\\) is the damping ratio.</p> <p>The solution to the above harmonic oscillator is</p> \\[ x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)     e^{-\\zeta \\omega t}, \\] <p>where</p> \\[ \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}. \\] <p>A Simple Harmonic Oscillator (\\(\\zeta=0\\))</p> <p>In a one dimensional world, a mass \\(m\\), driven by a force \\(F=-kx\\), is described as</p> \\[ \\begin{align} F &amp;= - k x \\\\ F &amp;= m a \\end{align} \\] <p>The mass behaves like a simple harmonic oscillator.</p> <p>In general, the solution to a simple harmonic oscillator is</p> \\[ x(t) = A \\cos(\\omega t + \\phi), \\] <p>where \\(\\omega\\) is the angular frequency, \\(\\phi\\) is the initial phase, and \\(A\\) is the amplitude.</p> <p>To use this generator,</p> <pre><code>params = {\"omega\": omega}\n\nho = HarmonicOscillator(params=params)\n\ndf = ho(n_periods=1, n_samples_per_period=10)\n</code></pre> <p><code>df</code> will be a pandas dataframe with two columns: <code>t</code> and <code>x</code>.</p> <ol> <li> <p>Contributors to Wikimedia projects. Harmonic oscillator.         In: Wikipedia [Internet]. 18 Feb 2024 [cited 20 Feb 2024].         Available: https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator \u21a9</p> </li> <li> <p>Libretexts. 5.3: General Solution for the Damped Harmonic Oscillator. Libretexts. 13 Apr 2021.             Available: https://t.ly/cWTIo. Accessed 20 Feb 2024.\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>Dict[str, float]</code> <p>all the params that defines the harmonic oscillator.</p> required <code>initial_condition</code> <code>Optional[Dict[str, float]]</code> <p>the initial condition of the harmonic oscillator.</p> <code>{}</code> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class HarmonicOscillator:\n    r\"\"\"Generate time series data for a [harmonic oscillator](https://en.wikipedia.org/wiki/Harmonic_oscillator).\n\n    The equation for a general un-driven harmonic oscillator is[^wiki_ho][^libretext_ho]\n\n    $$\n    \\frac{\\mathrm d x^2}{\\mathrm d t^2} + 2\\zeta \\omega \\frac{\\mathrm d x}{\\mathrm dt} + \\omega^2 x = 0,\n    $$\n\n    where $x$ is the displacement, $\\omega$ is the angular frequency of an undamped oscillator ($\\zeta=0$),\n    and $\\zeta$ is the damping ratio.\n\n    [^wiki_ho]: Contributors to Wikimedia projects. Harmonic oscillator.\n                In: Wikipedia [Internet]. 18 Feb 2024 [cited 20 Feb 2024].\n                Available: https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator\n\n    [^libretext_ho]: Libretexts. 5.3: General Solution for the Damped Harmonic Oscillator. Libretexts. 13 Apr 2021.\n                    Available: https://t.ly/cWTIo. Accessed 20 Feb 2024.\n\n\n    The solution to the above harmonic oscillator is\n\n    $$\n    x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n        e^{-\\zeta \\omega t},\n    $$\n\n    where\n\n    $$\n    \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n    $$\n\n\n    !!! example \"A Simple Harmonic Oscillator ($\\zeta=0$)\"\n\n        In a one dimensional world, a mass $m$, driven by a force $F=-kx$, is described as\n\n        $$\n        \\begin{align}\n        F &amp;= - k x \\\\\n        F &amp;= m a\n        \\end{align}\n        $$\n\n        The mass behaves like a simple harmonic oscillator.\n\n        In general, the solution to a simple harmonic oscillator is\n\n        $$\n        x(t) = A \\cos(\\omega t + \\phi),\n        $$\n\n        where $\\omega$ is the angular frequency, $\\phi$ is the initial phase, and $A$ is the amplitude.\n\n\n    To use this generator,\n\n    ```python\n    params = {\"omega\": omega}\n\n    ho = HarmonicOscillator(params=params)\n\n    df = ho(n_periods=1, n_samples_per_period=10)\n    ```\n\n    `df` will be a pandas dataframe with two columns: `t` and `x`.\n\n    :param system: all the params that defines the harmonic oscillator.\n    :param initial_condition: the initial condition of the harmonic oscillator.\n    \"\"\"\n\n    def __init__(\n        self,\n        system: Dict[str, float],\n        initial_condition: Optional[Dict[str, float]] = {},\n    ):\n        self.system = HarmonicOscillatorSystem.model_validate(system)\n        self.initial_condition = HarmonicOscillatorIC.model_validate(initial_condition)\n\n    @cached_property\n    def definition(self) -&gt; Dict[str, float]:\n        \"\"\"model params and initial conditions defined as a dictionary.\"\"\"\n        return {\n            \"system\": self.system.model_dump(),\n            \"initial_condition\": self.initial_condition.model_dump(),\n        }\n\n    def _x_simple(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n        r\"\"\"Solution to simple harmonic oscillators:\n\n        $$\n        x(t) = x_0 \\cos(\\omega t).\n        $$\n        \"\"\"\n        return self.initial_condition.x0 * np.cos(self.system.omega * t)\n\n    def _x_under_damped(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n        r\"\"\"Solution to under damped harmonic oscillators:\n\n        $$\n        x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n        e^{-\\zeta \\omega t},\n        $$\n\n        where\n\n        $$\n        \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n        $$\n        \"\"\"\n        omega_damp = self.system.omega * np.sqrt(1 - self.system.zeta)\n        return (\n            self.initial_condition.x0 * np.cos(omega_damp * t)\n            + (\n                self.system.zeta * self.system.omega * self.initial_condition.x0\n                + self.initial_condition.v0\n            )\n            / omega_damp\n            * np.sin(omega_damp * t)\n        ) * np.exp(-self.system.zeta * self.system.omega * t)\n\n    def _x_critical_damped(\n        self, t: Union[float, np.ndarray]\n    ) -&gt; Union[float, np.ndarray]:\n        r\"\"\"Solution to critical damped harmonic oscillators:\n\n        $$\n        x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n        e^{-\\zeta \\omega t},\n        $$\n\n        where\n\n        $$\n        \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n        $$\n        \"\"\"\n        return self.initial_condition.x0 * np.exp(\n            -self.system.zeta * self.system.omega * t\n        )\n\n    def _x_over_damped(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n        r\"\"\"Solution to over harmonic oscillators:\n\n        $$\n        x(t) = \\left( x_0 \\cosh(\\Gamma t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Gamma} \\sinh(\\Gamma t) \\right)\n        e^{-\\zeta \\omega t},\n        $$\n\n        where\n\n        $$\n        \\Gamma = \\omega\\sqrt{ \\zeta^2 - 1 }.\n        $$\n        \"\"\"\n        gamma_damp = self.system.omega * np.sqrt(self.system.zeta - 1)\n\n        return (\n            self.initial_condition.x0 * np.cosh(gamma_damp * t)\n            + (\n                self.system.zeta * self.system.omega * self.initial_condition.x0\n                + self.initial_condition.v0\n            )\n            / gamma_damp\n            * np.sinh(gamma_damp * t)\n        ) * np.exp(-self.system.zeta * self.system.omega * t)\n\n    def __call__(self, n_periods: int, n_samples_per_period: int) -&gt; pd.DataFrame:\n        \"\"\"Generate time series data for the harmonic oscillator.\n\n        Returns a list of floats representing the displacement at each time step.\n\n        :param n_periods: Number of periods to generate.\n        :param n_samples_per_period: Number of samples per period.\n        \"\"\"\n        time_delta = self.system.period / n_samples_per_period\n        time_steps = np.arange(0, n_periods * n_samples_per_period) * time_delta\n\n        if self.system.type == \"simple\":\n            data = self._x_simple(time_steps)\n        elif self.system.type == \"under_damped\":\n            data = self._x_under_damped(time_steps)\n        elif self.system.type == \"over_damped\":\n            data = self._x_over_damped(time_steps)\n        elif self.system.type == \"critical_damped\":\n            data = self._x_critical_damped(time_steps)\n        else:\n            raise ValueError(f\"system type is not defined: {self.system.type}\")\n\n        return pd.DataFrame({\"t\": time_steps, \"x\": data})\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillator.definition","title":"<code>definition: Dict[str, float]</code>  <code>cached</code> <code>property</code>","text":"<p>model params and initial conditions defined as a dictionary.</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillator.__call__","title":"<code>__call__(n_periods, n_samples_per_period)</code>","text":"<p>Generate time series data for the harmonic oscillator.</p> <p>Returns a list of floats representing the displacement at each time step.</p> <p>Parameters:</p> Name Type Description Default <code>n_periods</code> <code>int</code> <p>Number of periods to generate.</p> required <code>n_samples_per_period</code> <code>int</code> <p>Number of samples per period.</p> required Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def __call__(self, n_periods: int, n_samples_per_period: int) -&gt; pd.DataFrame:\n    \"\"\"Generate time series data for the harmonic oscillator.\n\n    Returns a list of floats representing the displacement at each time step.\n\n    :param n_periods: Number of periods to generate.\n    :param n_samples_per_period: Number of samples per period.\n    \"\"\"\n    time_delta = self.system.period / n_samples_per_period\n    time_steps = np.arange(0, n_periods * n_samples_per_period) * time_delta\n\n    if self.system.type == \"simple\":\n        data = self._x_simple(time_steps)\n    elif self.system.type == \"under_damped\":\n        data = self._x_under_damped(time_steps)\n    elif self.system.type == \"over_damped\":\n        data = self._x_over_damped(time_steps)\n    elif self.system.type == \"critical_damped\":\n        data = self._x_critical_damped(time_steps)\n    else:\n        raise ValueError(f\"system type is not defined: {self.system.type}\")\n\n    return pd.DataFrame({\"t\": time_steps, \"x\": data})\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillator._x_critical_damped","title":"<code>_x_critical_damped(t)</code>","text":"<p>Solution to critical damped harmonic oscillators:</p> \\[ x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right) e^{-\\zeta \\omega t}, \\] <p>where</p> \\[ \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}. \\] Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def _x_critical_damped(\n    self, t: Union[float, np.ndarray]\n) -&gt; Union[float, np.ndarray]:\n    r\"\"\"Solution to critical damped harmonic oscillators:\n\n    $$\n    x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n    e^{-\\zeta \\omega t},\n    $$\n\n    where\n\n    $$\n    \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n    $$\n    \"\"\"\n    return self.initial_condition.x0 * np.exp(\n        -self.system.zeta * self.system.omega * t\n    )\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillator._x_over_damped","title":"<code>_x_over_damped(t)</code>","text":"<p>Solution to over harmonic oscillators:</p> \\[ x(t) = \\left( x_0 \\cosh(\\Gamma t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Gamma} \\sinh(\\Gamma t) \\right) e^{-\\zeta \\omega t}, \\] <p>where</p> \\[ \\Gamma = \\omega\\sqrt{ \\zeta^2 - 1 }. \\] Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def _x_over_damped(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n    r\"\"\"Solution to over harmonic oscillators:\n\n    $$\n    x(t) = \\left( x_0 \\cosh(\\Gamma t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Gamma} \\sinh(\\Gamma t) \\right)\n    e^{-\\zeta \\omega t},\n    $$\n\n    where\n\n    $$\n    \\Gamma = \\omega\\sqrt{ \\zeta^2 - 1 }.\n    $$\n    \"\"\"\n    gamma_damp = self.system.omega * np.sqrt(self.system.zeta - 1)\n\n    return (\n        self.initial_condition.x0 * np.cosh(gamma_damp * t)\n        + (\n            self.system.zeta * self.system.omega * self.initial_condition.x0\n            + self.initial_condition.v0\n        )\n        / gamma_damp\n        * np.sinh(gamma_damp * t)\n    ) * np.exp(-self.system.zeta * self.system.omega * t)\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillator._x_simple","title":"<code>_x_simple(t)</code>","text":"<p>Solution to simple harmonic oscillators:</p> \\[ x(t) = x_0 \\cos(\\omega t). \\] Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def _x_simple(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n    r\"\"\"Solution to simple harmonic oscillators:\n\n    $$\n    x(t) = x_0 \\cos(\\omega t).\n    $$\n    \"\"\"\n    return self.initial_condition.x0 * np.cos(self.system.omega * t)\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillator._x_under_damped","title":"<code>_x_under_damped(t)</code>","text":"<p>Solution to under damped harmonic oscillators:</p> \\[ x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right) e^{-\\zeta \\omega t}, \\] <p>where</p> \\[ \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}. \\] Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>def _x_under_damped(self, t: Union[float, np.ndarray]) -&gt; Union[float, np.ndarray]:\n    r\"\"\"Solution to under damped harmonic oscillators:\n\n    $$\n    x(t) = \\left( x_0 \\cos(\\Omega t) + \\frac{\\zeta \\omega x_0 + v_0}{\\Omega} \\sin(\\Omega t) \\right)\n    e^{-\\zeta \\omega t},\n    $$\n\n    where\n\n    $$\n    \\Omega = \\omega\\sqrt{ 1 - \\zeta^2}.\n    $$\n    \"\"\"\n    omega_damp = self.system.omega * np.sqrt(1 - self.system.zeta)\n    return (\n        self.initial_condition.x0 * np.cos(omega_damp * t)\n        + (\n            self.system.zeta * self.system.omega * self.initial_condition.x0\n            + self.initial_condition.v0\n        )\n        / omega_damp\n        * np.sin(omega_damp * t)\n    ) * np.exp(-self.system.zeta * self.system.omega * t)\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorIC","title":"<code>HarmonicOscillatorIC</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The initial condition for a harmonic oscillator</p> <p>Attributes:</p> Name Type Description <code>x0</code> <code>float</code> <p>the initial displacement</p> <code>v0</code> <code>float</code> <p>the initial velocity</p> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class HarmonicOscillatorIC(BaseModel):\n    \"\"\"The initial condition for a harmonic oscillator\n\n    :cvar x0: the initial displacement\n    :cvar v0: the initial velocity\n    \"\"\"\n\n    x0: float = 1.0\n    v0: float = 0.0\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem","title":"<code>HarmonicOscillatorSystem</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>The params for the harmonic oscillator</p> <p>Attributes:</p> Name Type Description <code>omega</code> <code>float</code> <p>angular frequency of the harmonic oscillator</p> <code>zeta</code> <code>float</code> <p>damping ratio</p> Source code in <code>hamilflow/models/harmonic_oscillator.py</code> <pre><code>class HarmonicOscillatorSystem(BaseModel):\n    \"\"\"The params for the harmonic oscillator\n\n    :cvar omega: angular frequency of the harmonic oscillator\n    :cvar zeta: damping ratio\n    \"\"\"\n\n    omega: float\n    zeta: float = 0.0\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def period(self) -&gt; float:\n        \"\"\"period of the oscillator\"\"\"\n        return 2 * np.pi / self.omega\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def frequency(self) -&gt; float:\n        \"\"\"frequency of the oscillator\"\"\"\n        return 1 / self.period\n\n    @computed_field  # type: ignore[misc]\n    @cached_property\n    def type(\n        self,\n    ) -&gt; Literal[\"simple\", \"under_damped\", \"critical_damped\", \"over_damped\"]:\n        \"\"\"which type of harmonic oscillators\"\"\"\n        if self.zeta == 0:\n            return \"simple\"\n        elif self.zeta &lt; 1:\n            return \"under_damped\"\n        elif self.zeta == 1:\n            return \"critical_damped\"\n        else:\n            return \"over_damped\"\n\n    @field_validator(\"zeta\")\n    @classmethod\n    def check_zeta_non_negative(cls, v: float) -&gt; float:\n        if v &lt; 0:\n            raise ValueError(f\"Value of zeta should be possitive: {v=}\")\n\n        return v\n</code></pre>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem.frequency","title":"<code>frequency: float</code>  <code>cached</code> <code>property</code>","text":"<p>frequency of the oscillator</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem.period","title":"<code>period: float</code>  <code>cached</code> <code>property</code>","text":"<p>period of the oscillator</p>"},{"location":"references/models/harmonic_oscillator/#hamilflow.models.harmonic_oscillator.HarmonicOscillatorSystem.type","title":"<code>type: Literal['simple', 'under_damped', 'critical_damped', 'over_damped']</code>  <code>cached</code> <code>property</code>","text":"<p>which type of harmonic oscillators</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>We provide some tutorials to help you get started.</p>"},{"location":"tutorials/harmonic_oscillator/","title":"Harmonic Oscillators","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport plotly.express as px\n\nfrom hamilflow.models.harmonic_oscillator import HarmonicOscillator\n</pre> import pandas as pd import plotly.express as px  from hamilflow.models.harmonic_oscillator import HarmonicOscillator <pre>/tmp/ipykernel_1911/3199496368.py:1: DeprecationWarning: \nPyarrow will become a required dependency of pandas in the next major release of pandas (pandas 3.0),\n(to allow more performant data types, such as the Arrow string type, and better interoperability with other libraries)\nbut was not found to be installed on your system.\nIf this would cause problems for you,\nplease provide us feedback at https://github.com/pandas-dev/pandas/issues/54466\n        \n  import pandas as pd\n</pre> In\u00a0[2]: Copied! <pre>n_periods = 3\nn_samples_per_period = 200\n</pre> n_periods = 3 n_samples_per_period = 200 In\u00a0[3]: Copied! <pre>sho_omega = 0.5\n\nsho = HarmonicOscillator(system={\"omega\": sho_omega})\n</pre> sho_omega = 0.5  sho = HarmonicOscillator(system={\"omega\": sho_omega}) In\u00a0[4]: Copied! <pre>df_sho = sho(n_periods=n_periods, n_samples_per_period=n_samples_per_period)\ndf_sho.head()\n</pre> df_sho = sho(n_periods=n_periods, n_samples_per_period=n_samples_per_period) df_sho.head() Out[4]: t x 0 0.000000 1.000000 1 0.062832 0.999507 2 0.125664 0.998027 3 0.188496 0.995562 4 0.251327 0.992115 In\u00a0[5]: Copied! <pre>px.line(\n    df_sho,\n    x=\"t\",\n    y=\"x\",\n    title=rf\"Simple Harmonic Oscillator (omega = {sho_omega})\",\n    labels={\n        \"x\": r\"Displacement $x(t)$\",\n        \"t\": r\"$t$\",\n    },\n)\n</pre> px.line(     df_sho,     x=\"t\",     y=\"x\",     title=rf\"Simple Harmonic Oscillator (omega = {sho_omega})\",     labels={         \"x\": r\"Displacement $x(t)$\",         \"t\": r\"$t$\",     }, ) In\u00a0[6]: Copied! <pre>dho_systems = {\n    \"Underdamped\": {\"omega\": 0.5, \"zeta\": 0.2},\n    \"Critical Damped\": {\"omega\": 0.5, \"zeta\": 1},\n    \"Overdamped\": {\n        \"omega\": 0.5,\n        \"zeta\": 1.2,\n    },\n}\n\ndfs_dho = []\n\nfor s_name, s in dho_systems.items():\n\n    dfs_dho.append(\n        HarmonicOscillator(system=s)(\n            n_periods=n_periods, n_samples_per_period=n_samples_per_period\n        ).assign(system=rf\"{s_name} (omega = {s.get('omega')}, zeta = {s.get('zeta')})\")\n    )\n\nfig = px.line(\n    pd.concat(dfs_dho),\n    x=\"t\",\n    y=\"x\",\n    color=\"system\",\n    title=rf\"Damped Harmonic Oscillator\",\n    labels={\n        \"x\": r\"Displacement $x(t)$\",\n        \"t\": r\"$t$\",\n    },\n)\nfig.update_layout(legend={\"yanchor\": \"top\", \"y\": -0.2, \"xanchor\": \"left\", \"x\": 0})\n</pre> dho_systems = {     \"Underdamped\": {\"omega\": 0.5, \"zeta\": 0.2},     \"Critical Damped\": {\"omega\": 0.5, \"zeta\": 1},     \"Overdamped\": {         \"omega\": 0.5,         \"zeta\": 1.2,     }, }  dfs_dho = []  for s_name, s in dho_systems.items():      dfs_dho.append(         HarmonicOscillator(system=s)(             n_periods=n_periods, n_samples_per_period=n_samples_per_period         ).assign(system=rf\"{s_name} (omega = {s.get('omega')}, zeta = {s.get('zeta')})\")     )  fig = px.line(     pd.concat(dfs_dho),     x=\"t\",     y=\"x\",     color=\"system\",     title=rf\"Damped Harmonic Oscillator\",     labels={         \"x\": r\"Displacement $x(t)$\",         \"t\": r\"$t$\",     }, ) fig.update_layout(legend={\"yanchor\": \"top\", \"y\": -0.2, \"xanchor\": \"left\", \"x\": 0}) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/harmonic_oscillator/#harmonic-oscillators","title":"Harmonic Oscillators\u00b6","text":"<p>In this tutorial, we demo how to generate data of harmonic oscillators.</p>"},{"location":"tutorials/harmonic_oscillator/#simple-harmonic-oscillator","title":"Simple Harmonic Oscillator\u00b6","text":""},{"location":"tutorials/harmonic_oscillator/#damped-harmonic-oscillator","title":"Damped Harmonic Oscillator\u00b6","text":""}]}